# Onion Lasagna Architecture Documentation


# Philosophy
> Why this architecture and when to use it

## Core Principles

### 1. Business Logic is Framework-Free

Domain code never knows about:
- HTTP frameworks (Express, Fastify, etc.)
- Database clients (Drizzle, Prisma, etc.)
- Cloud providers
- Environment variables

**Why?** Frameworks change. Your business rules shouldn't.

### 2. Dependencies Flow Inward

```
Presentation → Infrastructure → Orchestrations → Bounded Contexts
```

Inner layers never import from outer layers.

### 3. Contracts are the Source of Truth

- **Read Models** define shared data shapes
- **Request/Response DTOs** define API contracts
- Frontend and backend share the same schemas

---

## When to Use

### Good Fit ✅
- Medium to large applications
- Multiple bounded contexts
- Complex business rules
- Long-term maintainability matters

### Not a Good Fit ❌
- Simple CRUD apps
- Prototypes / MVPs
- Minimal business logic

---

## Tradeoffs

### What You Gain
- **Testability** — Pure domain logic, easy mocking
- **Flexibility** — Swap databases, frameworks
- **Clarity** — Each layer has one job
- **Scalability** — BCs can become services

### What You Pay
- **More files** — Ports, DTOs, mappers
- **Learning curve** — New developers need onboarding
- **Indirection** — Request flows through layers
---

# Glossary
> Terms and definitions for Onion Lasagna Architecture

## Layers

**Bounded Context (BC)**
: A logical boundary with its own domain model, language, and rules. BCs don't import from each other directly.

**Orchestrations**
: Coordinates operations across multiple BCs. Three types: Compositions, Workflows, Projections.

**Infrastructure**
: Implements outbound ports. Contains persistence (databases) and external (API clients).

**Presentation**
: HTTP handlers, controllers, access guards, and mappers.

---

## Orchestration Types

**Composition**
: Read-only query that fans out to multiple BCs and aggregates results.

**Workflow**
: Command with side effects that may span multiple BCs. May include compensation logic.

**Projection**
: Denormalized read store. Can read from shared database, writes only to its own storage.

---

## Ports

**Inbound Port**
: Interface that defines how external actors interact with the BC. Implemented by use cases.

**Outbound Port**
: Interface that defines how the BC interacts with external systems. Implemented by infrastructure.

---

## Domain

**Aggregate**
: Cluster of domain objects treated as a single unit. Enforces business invariants.

**Entity**
: Domain object with unique identity that persists over time.

**Value Object (VO)**
: Immutable object defined by its attributes, not identity. Used for type safety.

---

## Data

**DTO (Data Transfer Object)**
: Object that carries data between layers. Immutable, validated at creation.

**Read Model**
: DTO optimized for display. Returned by Query Repositories.

---

## Repositories

**Query Repository**
: Returns Read Models. Optimized for display.

**Read Repository**
: Returns Aggregates. Used before modifications.

**Write Repository**
: Persists Aggregates. Returns void or ID.

---

## Presentation

**Access Guard**
: Stateless gate-keeper at controller level. Receives use cases via DI, cannot implement custom logic.

**Mapper**
: Pure function that transforms data between HTTP and use case shapes.
---

# Overview
> Layer structure, dependencies, and request flow

## Layer Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      PRESENTATION                           │
│  HTTP handlers, controllers, access guards, mappers         │
│  CAN import: All inner layers                               │
├─────────────────────────────────────────────────────────────┤
│                      INFRASTRUCTURE                         │
│  Implementations, Persistence, External                     │
│  CAN import: BC ports, domain (VOs, aggregates), shared     │
├─────────────────────────────────────────────────────────────┤
│                      ORCHESTRATIONS                         │
│  Compositions, Workflows, Projections                       │
│  CAN import: BC ports + use cases                           │
├─────────────────────────────────────────────────────────────┤
│                    BOUNDED CONTEXTS                         │
│  Domain + Use Cases + Ports                                 │
│  CAN import: Shared only (NO frameworks, NO env vars)       │
├─────────────────────────────────────────────────────────────┤
│                         SHARED                              │
│  Read Models, Enums, Generated Clients                      │
└─────────────────────────────────────────────────────────────┘
                   Dependencies flow INWARD →
```

---

## Dependency Rules

| Layer | Can Import |
|-------|------------|
| **Presentation** | Infrastructure, Orchestrations, Bounded Contexts, Shared |
| **Infrastructure** | BC ports, domain (VOs, aggregates), Shared |
| **Orchestrations** | BC ports + use cases, Shared |
| **Bounded Contexts** | Shared only |
| **Shared** | Nothing (leaf layer) |

---

## Request Flow

```
HTTP Request
    │
    ▼
Handler ─────────────────► Extracts event, generates ExecutionContext
    │
    ▼
Controller ──────────────► Validates, authorizes, maps
    │
    ▼
Use Case / Orchestration ► Business logic
    │
    ▼
Outbound Port Implementation
    │
    ▼
Persistence / External ──► Database or API call
    │
    ▼
Response bubbles back up
```

---

## Folder Structure

### Module-Based

```
packages/backend/
├── modules/{module}/
│   ├── bounded-contexts/{bc}/
│   │   ├── app/
│   │   │   ├── ports/inbound/
│   │   │   ├── ports/outbound/
│   │   │   └── use-cases/
│   │   ├── domain/
│   │   └── infra/
│   ├── orchestrations/
│   ├── presentation/
│   └── shared-infra/
└── shared-infra/
```

### Simple

```
packages/backend/
├── bounded-contexts/{bc}/
├── orchestrations/
├── presentation/
└── shared-infra/
```
---

# Presentation
> HTTP handlers, controllers, access guards, and mappers

HTTP layer: handlers, controllers, access guards, mappers.

---

## Structure

```
presentation/
└── http/
    ├── service.metadata.ts
    └── {resource}/
        ├── route.metadata.ts
        └── {endpoint}/
            ├── endpoint.metadata.ts
            ├── request.dto.ts         ← Source of truth
            ├── response.dto.ts        ← Source of truth
            ├── access-guard.ts
            ├── to-use-case.mapper.ts
            └── to-response.mapper.ts
```

---

## Request/Response DTOs

These are the **source of truth** for API contracts.

```typescript:request.dto.ts
const findUserByIdRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});

type FindUserByIdRequest = z.infer;
```

```typescript:response.dto.ts
const findUserByIdResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});

type FindUserByIdResponse = z.infer;
```

---

## Access Guards

Stateless gate-keepers. Receive use cases via DI.

**Rules:**
- ✅ Receive use cases via dependency injection
- ✅ Delegate authorization logic to use cases
- ❌ Cannot implement custom business logic

```typescript:access-guard.ts
class CanManageResourceGuard {
  constructor(
    private readonly canManageResourceQuery: CanManageResourceQueryInboundPort,
  ) {}

  async guard(request: Request): Promise {
    const result = await this.canManageResourceQuery.execute({
      userId: request.executionContext.userId,
      resourceId: request.pathParams.resourceId,
    });
    return { isAllowed: result.allowed, reason: result.reason };
  }
}
```

---

## Mappers

Pure functions transforming between HTTP and use case shapes.

```typescript:to-use-case.mapper.ts
function toFindUserByIdInput(request: FindUserByIdRequest): FindUserByIdInput {
  return { userId: request.pathParams.userId };
}

// to-response.mapper.ts
function toFindUserByIdResponse(output: FindUserByIdOutput): FindUserByIdResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

---

## Execution Context

Generated at controller level. **Never a frontend concern.**

```typescript
// Inside controller/handler
const executionContext = {
  userId: extractUserIdFromToken(request),
  roles: extractRolesFromToken(request),
};
```

---

## Exception Handling

Controllers catch domain exceptions and map to HTTP status codes.

```typescript
// Framework-specific exception handler
try {
  const result = await useCase.execute(input);
  return response(200, result);
} catch (error) {
  if (error instanceof NotFoundError) return response(404, error.message);
  if (error instanceof InvalidRequestError) return response(400, error.message);
  throw error;
}
```
---

# Infrastructure
> Implement outbound ports with persistence and external services

Implements outbound ports. Three-tier structure.

---

## Structure

```
infra/ (or shared-infra/)
├── implementations/           ← Outbound port implementations (uses `implements`)
│   └── {resource}/
│       └── {resource}.repository.ts
├── persistence/               ← Raw database access (NO `implements`)
│   └── drizzle/
│       └── {resource}/
└── external/                  ← Raw API adapters (NO `implements`)
    └── {service-name}/
```

---

## Key Rule

**Only `implementations/` uses the `implements` keyword.**

Persistence and external are plain classes that the implementations orchestrate.

---

## Example

### Persistence (Raw Database)

```typescript:persistence/drizzle/user/user.persistence.ts
class UserPersistence {
  async findById(id: string): Promise {
    return db.select().from(users).where(eq(users.id, id)).limit(1)[0];
  }

  async insert(data: UserRow): Promise {
    await db.insert(users).values(data);
  }
}
```

### Implementation (Outbound Port)

```typescript:implementations/user/user.repository.ts
class UserRepository implements UserRepositoryOutboundPort {
  constructor(private readonly persistence: UserPersistence) {}

  async findById(id: UserId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return UserAggregate.reconstitute(row);  // Hydrates aggregate
  }

  async save(user: UserAggregate): Promise {
    await this.persistence.insert({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

---

## Shared-Infra Scoping

| Scope | Location | Use When |
|-------|----------|----------|
| Global | `/packages/backend/shared-infra/` | Shared across all modules |
| Module | `/modules/{module}/shared-infra/` | Shared across BCs in one module |
| BC | `/bounded-contexts/{bc}/infra/` | Scoped to single BC |

Simple systems can share a single database + ORM via shared-infra.

---

## Aggregate Hydration

Repositories are responsible for hydrating aggregates using `Aggregate.reconstitute()`.

**Prefer partial loading** over full loading when possible.

---

## Environment Variables

- ❌ **Prohibited** in Bounded Contexts
- ✅ **Allowed** in Infrastructure (persistence, external, implementations)
---

# Orchestrations
> Coordinate operations across multiple Bounded Contexts

Coordinates operations across multiple Bounded Contexts.

---

## When to Use

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Three Types

| Type | Purpose | Example |
|------|---------|---------|
| **Composition** | Read-only, multi-BC query | GET order with customer + products |
| **Workflow** | Write, multi-BC command | Checkout: order + inventory + payment |
| **Projection** | Denormalized read store | Dashboard aggregating multiple BCs |

---

## Structure

```
orchestrations/
├── compositions/
│   ├── ports/
│   └── use-cases/
├── workflows/
│   ├── ports/
│   └── use-cases/
└── projections/
    ├── ports/
    ├── use-cases/
    └── infra/              ← Projection's own infrastructure
```

---

## Composition

```typescript:compositions/use-cases/get-order-details.composition.ts
class GetOrderDetailsComposition implements GetOrderDetailsCompositionInboundPort {
  constructor(
    orderQueryRepo: OrderQueryRepositoryOutboundPort,
    customerQueryRepo: CustomerQueryRepositoryOutboundPort,
  ) {
    this.findOrderQuery = new FindOrderByIdQuery(orderQueryRepo);
    this.findCustomerQuery = new FindCustomerByIdQuery(customerQueryRepo);
  }

  async execute(input: GetOrderDetailsInput): Promise {
    const order = await this.findOrderQuery.execute({ orderId: input.orderId });
    const customer = await this.findCustomerQuery.execute({ customerId: order.customerId });
    return { order, customer };
  }
}
```

---

## Workflow

```typescript:workflows/use-cases/process-checkout.workflow.ts
class ProcessCheckoutWorkflow implements ProcessCheckoutWorkflowInboundPort {
  async execute(input: ProcessCheckoutInput): Promise {
    const order = await this.createOrderCommand.execute({ ... });
    
    try {
      await this.reserveInventoryCommand.execute({ orderId: order.id });
      await this.processPaymentCommand.execute({ orderId: order.id });
      return { orderId: order.id, status: 'COMPLETED' };
    } catch (error) {
      await this.cancelOrderCommand.execute({ orderId: order.id });
      throw error;
    }
  }
}
```

---

## Projection

Projections have their own infrastructure layer for denormalized storage.

**Rules:**
- CAN read from shared database
- CAN write only to its own denormalized storage
- For simple systems with shared DB, may not need separate storage

```typescript:projections/use-cases/user-dashboard.projection.ts
class UserDashboardProjection implements UserDashboardProjectionInboundPort {
  async execute(input: UserDashboardInput): Promise {
    // Reads from multiple BCs, returns aggregated view
  }
}
```

---

## Naming

| Type | Interface | File |
|------|-----------|------|
| Composition | `{Name}CompositionInboundPort` | `.composition.ts` |
| Workflow | `{Name}WorkflowInboundPort` | `.workflow.ts` |
| Projection | `{Name}ProjectionInboundPort` | `.projection.ts` |
---

# Bounded Contexts
> Pure domain logic with ports and use cases

Pure domain logic, completely framework-free.

---

## Structure

```
bounded-contexts/{bc-name}/
├── app/
│   ├── ports/
│   │   ├── inbound/           ← Use case interfaces
│   │   └── outbound/          ← Repository interfaces
│   └── use-cases/
│       ├── queries/
│       └── commands/
├── domain/
│   ├── aggregates/
│   ├── entities/
│   ├── value-objects/
│   └── exceptions/
└── infra/                      ← BC-scoped implementations
```

---

## Golden Rules

1. **NO framework imports**
2. **NO environment variables**
3. **NO direct cross-BC imports**
4. **CAN import** from domain (VOs, aggregates) into infra

---

## Inbound Ports

Interfaces for use cases. Implemented by queries and commands.

```typescript:ports/inbound/find-user-by-id.query.inbound.ts
interface FindUserByIdQueryInboundPort {
  execute(input: FindUserByIdInput): Promise;
}
```

### Naming

| Type | Interface | File |
|------|-----------|------|
| Query | `{Name}QueryInboundPort` | `.query.inbound.ts` |
| Command | `{Name}CommandInboundPort` | `.command.inbound.ts` |

---

## Outbound Ports

Interfaces for external dependencies. Implemented by infrastructure.

```typescript:ports/outbound/user.repository.outbound.ts
interface UserRepositoryOutboundPort {
  findById(id: UserId): Promise;
  save(user: User): Promise;
}
```

---

## Use Cases

Implement inbound ports.

```typescript:use-cases/queries/find-user-by-id.query.ts
class FindUserByIdQuery implements FindUserByIdQueryInboundPort {
  constructor(
    private readonly userRepo: UserRepositoryOutboundPort,
  ) {}

  async execute(input: FindUserByIdInput): Promise {
    const user = await this.userRepo.findById(UserId.create(input.userId));
    if (!user) throw new UserNotFoundError(input.userId);
    return { id: user.id.value, email: user.email, name: user.name };
  }
}
```

---

## Domain

### Aggregates

```typescript
class UserAggregate {
  private constructor(
    private readonly _id: UserId,
    private _email: string,
    private _name: string,
  ) {}

  static create(data: CreateUserData): UserAggregate { ... }
  static reconstitute(data: UserData): UserAggregate { ... }
}
```

### Value Objects

```typescript
class UserId {
  private constructor(private readonly _value: string) {}
  static create(value: string): UserId { ... }
  static generate(): UserId { ... }
  get value(): string { return this._value; }
}
```

See [Aggregates](../patterns/aggregates.md) and [Value Objects](../patterns/value-objects.md) for details.
---

# DTOs
> Data Transfer Objects for carrying data between layers. Immutable, validated at creation.

## Types

| DTO | Purpose | Location |
|-----|---------|----------|
| **Request DTO** | HTTP request shape | `presentation/http/{endpoint}/request.dto.ts` |
| **Response DTO** | HTTP response shape | `presentation/http/{endpoint}/response.dto.ts` |
| **Input DTO** | Use case input | `app/ports/inbound/{use-case}/` |
| **Output DTO** | Use case output | `app/ports/inbound/{use-case}/` |

---

## BaseDto Class

All DTOs extend `BaseDto` which provides:
- Immutable data access via `.data` getter
- Automatic validation at construction
- Support for skipping validation when reconstituting from trusted sources

```typescript




// Define your schema
const createUserRequestSchema = z.object({
  body: z.object({
    email: z.string().email(),
    name: z.string().min(1).max(100),
    password: z.string().min(8),
  }),
});

type CreateUserRequestData = z.infer;

// Create a DTO class extending BaseDto
class CreateUserRequestDto extends BaseDto {
  private constructor(data: CreateUserRequestData) {
    super(data, createZodValidator(createUserRequestSchema));
  }

  static create(data: unknown): CreateUserRequestDto {
    // Validates and throws ObjectValidationError if invalid
    return new CreateUserRequestDto(data as CreateUserRequestData);
  }

  // Convenience getters
  get email(): string {
    return this.data.body.email;
  }

  get name(): string {
    return this.data.body.name;
  }
}
```

---

## Use Case DTOs

Input and output DTOs follow the same pattern:

```typescript
const createUserInputSchema = z.object({
  email: z.string().email(),
  name: z.string(),
  hashedPassword: z.string(),
});

type CreateUserInputData = z.infer;

class CreateUserInputDto extends BaseDto {
  private constructor(data: CreateUserInputData) {
    super(data, createZodValidator(createUserInputSchema));
  }

  static create(data: unknown): CreateUserInputDto {
    return new CreateUserInputDto(data as CreateUserInputData);
  }
}
```

---

## Skipping Validation

Use `SKIP_DTO_VALIDATION` when reconstituting from trusted sources (e.g., database, internal mapping):

```typescript
class UserOutputDto extends BaseDto {
  private constructor(data: UserOutputData, skipValidation = false) {
    super(data, skipValidation ? SKIP_DTO_VALIDATION : createZodValidator(schema));
  }

  static create(data: unknown): UserOutputDto {
    return new UserOutputDto(data as UserOutputData);
  }

  // For internal use when data is already validated
  static fromTrusted(data: UserOutputData): UserOutputDto {
    return new UserOutputDto(data, true);
  }
}
```

---

## Other Validators

The library supports multiple validators. Replace the Zod validator with your preferred choice:

```typescript
// ArkType



const schema = type({ email: 'string.email', name: 'string' });
super(data, createArkTypeValidator(schema));

// Valibot



const schema = v.object({ email: v.pipe(v.string(), v.email()), name: v.string() });
super(data, createValibotValidator(schema));

// TypeBox



const schema = Type.Object({ email: Type.String({ format: 'email' }), name: Type.String() });
super(data, createTypeBoxValidator(schema));
```

---

## Validation Errors

When validation fails, an `ObjectValidationError` is thrown with structured field-level errors:

```typescript
try {
  const dto = CreateUserRequestDto.create(invalidData);
} catch (error) {
  if (error instanceof ObjectValidationError) {
    // error.validationErrors is an array of { field: string; message: string }
    console.log(error.validationErrors);
    // [{ field: 'body.email', message: 'Invalid email format' }]
  }
}
```

Controllers automatically convert `ObjectValidationError` to `InvalidRequestError` with a 400 status code.

---

## DTO vs Value Object

| Aspect | DTO | Value Object |
|--------|-----|--------------|
| **Purpose** | Transfer data | Represent domain concept |
| **Location** | Presentation / App layer | Domain layer |
| **Behavior** | Minimal (data access) | May have methods |
| **Identity** | None | Compared by value |
| **Base Class** | `BaseDto` | `BaseValueObject` |
---

# Value Objects
> Immutable objects defined by their attributes, not identity. Used for type safety and validation.

## BaseValueObject

All value objects extend `BaseValueObject`:

```typescript




class Email extends BaseValueObject {
  private constructor(value: string, skipValidation = false) {
    super(
      value,
      skipValidation ? SKIP_VALUE_OBJECT_VALIDATION : createZodValidator(z.string().email()),
    );
  }

  static create(value: string): Email {
    return new Email(value);
  }

  // For reconstitution from trusted sources (e.g., database)
  static fromPersistence(value: string): Email {
    return new Email(value, true);
  }

  get domain(): string {
    return this.value.split('@')[1];
  }
}
```

Key features:
- **Immutable**: Value is set at construction and cannot be changed
- **Validated**: Validator runs at construction (unless skipped)
- **Comparable**: Built-in `equals()` method with deep equality

---

## Built-in Value Objects

The library provides base value objects you can extend:

### Text Types

```typescript

  BaseShortTextVo,   // Suggested: 1-100 characters
  BaseMediumTextVo,  // Suggested: 1-500 characters
  BaseLongTextVo,    // Suggested: 1-2000 characters
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

### Identifiers

```typescript

  BaseUuidV4Vo,  // UUID v4 format
  BaseUuidV7Vo,  // UUID v7 format (time-ordered)
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

### Contact

```typescript

```

### Pagination

```typescript


// Properties: page, pageSize
```

### Auditing

```typescript

  BaseAuditInfoVo,  // Combines by + on
  BaseAuditByVo,    // createdBy, updatedBy (optional UUIDs)
  BaseAuditOnVo,    // createdAt, updatedAt (with invariant check)
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

**Note**: `BaseAuditOnVo` enforces that `updatedAt` cannot be before `createdAt`.

---

## Ready-to-Use Value Objects

Each validator provides ready-to-use value objects:

```typescript
// Zod (same exports for arktype, valibot, typebox)

  EmailVo,
  UuidV4Vo,
  UuidV7Vo,
  ShortTextVo,
  MediumTextVo,
  LongTextVo,
  PaginationVo,
  AuditByVo,
  AuditOnVo,
  AuditInfoVo,
} from '@cosmneo/onion-lasagna/backend/core/validators/zod';

// Usage
const email = EmailVo.create('user@example.com');
const id = UuidV4Vo.generate();          // Generate new UUID
const existingId = UuidV4Vo.create(str); // Validate existing
const name = ShortTextVo.create('John Doe');
const page = PaginationVo.create({ page: 1, pageSize: 20 });
```

---

## Creating Custom Value Objects

### Simple Value Object

```typescript
class UserId extends BaseUuidV4Vo {
  static create(value: string): UserId {
    return new UserId(value);
  }

  static generate(): UserId {
    return UserId.create(crypto.randomUUID());
  }
}
```

### Value Object with Custom Validation

```typescript
const phoneSchema = z.string().regex(/^\+[1-9]\d{1,14}$/);

class PhoneNumber extends BaseValueObject {
  private constructor(value: string) {
    super(value, createZodValidator(phoneSchema));
  }

  static create(value: string): PhoneNumber {
    return new PhoneNumber(value);
  }

  get countryCode(): string {
    return this.value.slice(1, 3);
  }
}
```

### Composite Value Object

```typescript
interface AddressData {
  street: string;
  city: string;
  postalCode: string;
  country: string;
}

const addressSchema = z.object({
  street: z.string().min(1),
  city: z.string().min(1),
  postalCode: z.string().min(1),
  country: z.string().length(2),
});

class Address extends BaseValueObject {
  private constructor(data: AddressData) {
    super(data, createZodValidator(addressSchema));
  }

  static create(data: AddressData): Address {
    return new Address(data);
  }

  get street(): string { return this.value.street; }
  get city(): string { return this.value.city; }
  get fullAddress(): string {
    return `${this.value.street}, ${this.value.city}, ${this.value.country}`;
  }
}
```

---

## Equality Comparison

`BaseValueObject` provides deep equality via `equals()`:

```typescript
const email1 = EmailVo.create('user@example.com');
const email2 = EmailVo.create('user@example.com');
const email3 = EmailVo.create('other@example.com');

email1.equals(email2); // true (same value)
email1.equals(email3); // false (different value)
```

The comparison handles:
- Primitive values
- Nested objects
- Arrays
- Date objects

---

## Rules

- ✅ Extend `BaseValueObject` for consistency
- ✅ Use factory methods (`create`, `generate`)
- ✅ Use `SKIP_VALUE_OBJECT_VALIDATION` for trusted sources
- ✅ Add convenience getters for derived values
- ✅ Throw `ObjectValidationError` on invalid data (automatic with validators)
- ❌ Don't mutate after construction
- ❌ Don't use for complex objects (use Entities/Aggregates)
---

# Aggregates
> Entity clusters treated as a single unit. Enforce business invariants and emit domain events.

## BaseEntity and BaseAggregateRoot

The library provides base classes for entities and aggregates:

```typescript

  BaseEntity,
  BaseAggregateRoot,
  BaseDomainEvent,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

---

## BaseEntity

Entities have identity and can be compared by ID:

```typescript
abstract class BaseEntity,
  TProps extends object,
> {
  protected readonly _id: TId;
  protected _version: number;
  protected readonly _props: TProps;

  get id(): TId;
  get version(): number;
  get props(): TProps;

  equals(other: BaseEntity): boolean;
  nextVersion(): number;
}
```

---

## BaseAggregateRoot

Aggregates extend `BaseEntity` with domain event support:

```typescript
abstract class BaseAggregateRoot,
  TProps extends object,
> extends BaseEntity {
  // Add a domain event to be published
  protected addDomainEvent(event: BaseDomainEvent): void;

  // Get and clear all domain events (for publishing)
  public pullDomainEvents(): BaseDomainEvent[];

  // Peek at events without clearing
  public peekDomainEvents(): readonly BaseDomainEvent[];

  // Check if there are pending events
  public get hasDomainEvents(): boolean;

  // Clear all events (called after publishing)
  protected clearDomainEvents(): void;
}
```

---

## Creating an Aggregate

```typescript

  BaseAggregateRoot,
  BaseDomainEvent,
  InvariantViolationError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

interface OrderProps {
  customerId: CustomerId;
  items: OrderItem[];
  status: OrderStatus;
  createdAt: Date;
}

class OrderAggregate extends BaseAggregateRoot {
  private constructor(id: OrderId, props: OrderProps, version = 0) {
    super(id, props, version);
  }

  // Factory for NEW instances
  static create(data: CreateOrderData): OrderAggregate {
    const order = new OrderAggregate(
      OrderId.generate(),
      {
        customerId: CustomerId.create(data.customerId),
        items: [],
        status: OrderStatus.DRAFT,
        createdAt: new Date(),
      },
    );

    // Emit creation event
    order.addDomainEvent(new OrderCreatedEvent(order.id.value, data.customerId));

    return order;
  }

  // Factory for EXISTING instances (from DB)
  static reconstitute(data: OrderData, version: number): OrderAggregate {
    return new OrderAggregate(
      OrderId.create(data.id),
      {
        customerId: CustomerId.create(data.customerId),
        items: data.items.map(OrderItem.reconstitute),
        status: data.status,
        createdAt: data.createdAt,
      },
      version,
    );
  }

  // Domain methods (enforce invariants)
  addItem(item: AddItemData): void {
    if (this._props.status !== OrderStatus.DRAFT) {
      throw new InvariantViolationError({
        message: 'Cannot add items to non-draft order',
        code: 'ORDER_NOT_EDITABLE',
      });
    }
    if (this._props.items.length >= 50) {
      throw new InvariantViolationError({
        message: 'Maximum 50 items per order',
        code: 'ORDER_LIMIT_EXCEEDED',
      });
    }

    this._props.items.push(OrderItem.create(item));
    this.addDomainEvent(new OrderItemAddedEvent(this.id.value, item));
  }

  submit(): void {
    if (this._props.items.length === 0) {
      throw new InvariantViolationError({
        message: 'Cannot submit empty order',
        code: 'EMPTY_ORDER',
      });
    }

    this._props.status = OrderStatus.PENDING;
    this.addDomainEvent(new OrderSubmittedEvent(this.id.value));
  }

  // Getters
  get customerId(): CustomerId { return this._props.customerId; }
  get status(): OrderStatus { return this._props.status; }
  get items(): readonly OrderItem[] { return [...this._props.items]; }
}
```

---

## Domain Events

Create domain events by extending `BaseDomainEvent`:

```typescript


interface OrderCreatedPayload {
  customerId: string;
}

class OrderCreatedEvent extends BaseDomainEvent {
  constructor(aggregateId: string, customerId: string) {
    super('OrderCreated', aggregateId, { customerId });
  }
}

interface OrderSubmittedPayload {
  submittedAt: Date;
}

class OrderSubmittedEvent extends BaseDomainEvent {
  constructor(aggregateId: string) {
    super('OrderSubmitted', aggregateId, { submittedAt: new Date() });
  }
}
```

`BaseDomainEvent` provides:
- `eventId` - Unique ID for the event
- `eventName` - Name of the event
- `aggregateId` - ID of the aggregate that emitted it
- `occurredOn` - Timestamp when the event occurred
- `payload` - Event-specific data
- `toJSON()` - Serialize for storage/transport

---

## Publishing Domain Events

Use `pullDomainEvents()` to get and clear events after persisting:

```typescript
class CreateOrderCommand {
  constructor(
    private readonly orderRepo: OrderWriteRepositoryOutboundPort,
    private readonly eventPublisher: EventPublisherOutboundPort,
  ) {}

  async execute(input: CreateOrderInput): Promise {
    const order = OrderAggregate.create(input);

    // Persist first
    await this.orderRepo.save(order);

    // Then publish events (get and clear)
    const events = order.pullDomainEvents();
    await this.eventPublisher.publishAll(events);
  }
}
```

---

## Optimistic Locking

Use `version` and `nextVersion()` for optimistic concurrency:

```typescript
class OrderRepository {
  async save(order: OrderAggregate): Promise {
    const affectedRows = await this.db.query(
      `UPDATE orders SET ..., version = ? WHERE id = ? AND version = ?`,
      [order.nextVersion(), order.id.value, order.version],
    );

    if (affectedRows === 0) {
      throw new ConcurrencyError('Order was modified by another process');
    }
  }
}
```

---

## Rules

- ✅ Extend `BaseAggregateRoot` for event-sourced aggregates
- ✅ Use factory methods (`create`, `reconstitute`)
- ✅ Enforce all invariants in domain methods
- ✅ Use `InvariantViolationError` for business rule violations
- ✅ Emit domain events for state changes
- ✅ Return copies of collections from getters
- ✅ Reference other aggregates by ID only
- ✅ Use `version` for optimistic locking
- ❌ Never create with `new` directly
- ❌ Never reference other aggregates directly
- ❌ Never publish events before persisting

---

## Hydration

Repositories are responsible for hydrating aggregates:

```typescript
class OrderRepository extends BaseOutboundAdapter {
  async findById(id: OrderId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return OrderAggregate.reconstitute(row, row.version);
  }
}
```
---

# Repositories
> Provide access to aggregates and read models. Three types aligned with CQRS.

## Types

| Type | Returns | Used In |
|------|---------|---------|
| **Query Repository** | Read Models | Queries (display) |
| **Read Repository** | Aggregates | Commands (before mutation) |
| **Write Repository** | void / ID | Commands (persist) |

---

## Port Definition (Outbound)

```typescript:ports/outbound/user.repository.outbound.ts

interface UserQueryRepositoryOutboundPort {
  findPaginated(options: PaginationOptions): Promise>;
}

interface UserReadRepositoryOutboundPort {
  findById(id: UserId): Promise;
  findByEmail(email: Email): Promise;
}

interface UserWriteRepositoryOutboundPort {
  save(user: UserAggregate): Promise;
  delete(id: UserId): Promise;
}
```

---

## Implementation

```typescript:infra/implementations/user/user.repository.ts

class UserRepository implements 
  UserQueryRepositoryOutboundPort,
  UserReadRepositoryOutboundPort,
  UserWriteRepositoryOutboundPort 
{
  constructor(private readonly persistence: UserPersistence) {}

  async findById(id: UserId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return UserAggregate.reconstitute(row);
  }

  async save(user: UserAggregate): Promise {
    await this.persistence.upsert({
      id: user.id.value,
      email: user.email.value,
      name: user.name,
    });
  }
}
```

---

## Usage in Use Cases

```typescript
// Query use case
class FindUsersQuery {
  constructor(private readonly queryRepo: UserQueryRepositoryOutboundPort) {}

  async execute(input: FindUsersInput): Promise {
    return this.queryRepo.findPaginated(input.pagination);
  }
}

// Command use case
class CreateUserCommand {
  constructor(
    private readonly readRepo: UserReadRepositoryOutboundPort,
    private readonly writeRepo: UserWriteRepositoryOutboundPort,
  ) {}

  async execute(input: CreateUserInput): Promise {
    const existing = await this.readRepo.findByEmail(Email.create(input.email));
    if (existing) throw new EmailAlreadyExistsError(input.email);

    const user = UserAggregate.create(input);
    await this.writeRepo.save(user);
  }
}
```

---

## Rules

- ✅ Define ports in BC, implement in infrastructure
- ✅ Return Aggregates from Read Repository
- ✅ Return Read Models from Query Repository
- ✅ Hydrate aggregates in repository (not caller)
- ❌ Don't put business logic in repositories
---

# Validators
> Validator abstraction for schema validation. Supports Zod, ArkType, Valibot, and TypeBox.

## Overview

The library provides a validator abstraction layer that allows you to use your preferred validation library while maintaining consistent patterns across your codebase.

Supported validators:
- **Zod** - TypeScript-first schema validation
- **ArkType** - TypeScript's 1:1 validator
- **Valibot** - Modular, tree-shakeable validation
- **TypeBox** - JSON Schema Type Builder

---

## ObjectValidatorPort

The core abstraction is `ObjectValidatorPort`:

```typescript
interface ObjectValidatorPort {
  validateObject: ValidateObject;
  withSchema: (schema: TSchema) => BoundValidator;
}

interface BoundValidator {
  validate: (value: unknown) => T;
}
```

Each validator implementation converts validation errors to `ObjectValidationError` with structured field-level error messages.

---

## Factory Functions

Each validator exports a factory function that creates a `BoundValidator`:

```typescript
// Zod



const schema = z.object({ email: z.string().email() });
const validator = createZodValidator(schema);

// ArkType



const schema = type({ email: 'string.email' });
const validator = createArkTypeValidator(schema);

// Valibot



const schema = v.object({ email: v.pipe(v.string(), v.email()) });
const validator = createValibotValidator(schema);

// TypeBox



const schema = Type.Object({ email: Type.String({ format: 'email' }) });
const validator = createTypeBoxValidator(schema);
```

---

## Using with BaseDto

Inject validators into `BaseDto` constructors:

```typescript



class CreateUserDto extends BaseDto {
  private constructor(data: CreateUserData) {
    super(data, createZodValidator(createUserSchema));
  }

  static create(data: unknown): CreateUserDto {
    return new CreateUserDto(data as CreateUserData);
  }
}
```

---

## Using with BaseValueObject

Inject validators into `BaseValueObject` constructors:

```typescript



class Email extends BaseValueObject {
  private constructor(value: string) {
    super(value, createZodValidator(z.string().email()));
  }

  static create(value: string): Email {
    return new Email(value);
  }
}
```

---

## Pre-built Value Objects

Each validator exports ready-to-use value objects:

```typescript

  EmailVo,
  UuidV4Vo,
  UuidV7Vo,
  ShortTextVo,
  MediumTextVo,
  LongTextVo,
  PaginationVo,
  AuditByVo,
  AuditOnVo,
  AuditInfoVo,
} from '@cosmneo/onion-lasagna/backend/core/validators/zod';

// Usage
const email = EmailVo.create('user@example.com');
const id = UuidV4Vo.generate();
const name = ShortTextVo.create('John Doe');
```

All four validators (Zod, ArkType, Valibot, TypeBox) provide these same value objects with identical APIs.

---

## Error Handling

When validation fails, validators throw `ObjectValidationError`:

```typescript


try {
  const dto = CreateUserDto.create({ email: 'invalid' });
} catch (error) {
  if (error instanceof ObjectValidationError) {
    console.log(error.code);            // 'OBJECT_VALIDATION_ERROR'
    console.log(error.validationErrors); // [{ field: 'email', message: 'Invalid email' }]
  }
}
```

The `validationErrors` array contains structured errors:

```typescript
interface ValidationError {
  field: string;   // Dot-notation path: 'user.email', 'items[0].name'
  message: string; // Human-readable error message
}
```

---

## Swapping Validators

To switch validators, update your imports and schema definitions:

```typescript
// Before (Zod)


const schema = z.object({ name: z.string() });
const validator = createZodValidator(schema);

// After (Valibot)


const schema = v.object({ name: v.string() });
const validator = createValibotValidator(schema);
```

The `BoundValidator` interface remains the same, so your `BaseDto` and `BaseValueObject` classes continue working without changes.

---

## Validator Comparison

| Feature | Zod | ArkType | Valibot | TypeBox |
|---------|-----|---------|---------|---------|
| Bundle size | ~12kb | ~20kb | ~5kb | ~15kb |
| Type inference | Excellent | Excellent | Excellent | Good |
| Error messages | Detailed | Detailed | Customizable | Basic |
| Performance | Fast | Very fast | Fast | Very fast |
| Ecosystem | Large | Growing | Growing | Large |
---

# Error Handling
> Typed error hierarchy with error codes for consistent error handling across layers.

## Overview

The library provides a comprehensive error hierarchy based on `CodedError`. Each error type has a unique code for programmatic handling and maps to appropriate HTTP status codes.

---

## CodedError Base Class

All errors extend `CodedError`:

```typescript


abstract class CodedError extends Error {
  public readonly code: string;

  constructor(options: {
    message: string;
    code: string;
    cause?: unknown;
  });

  static fromError(cause: unknown): CodedError;
}
```

Key features:
- `code` - Machine-readable identifier for error handling
- `cause` - ES2022 error chaining support
- `fromError()` - Factory method for wrapping unknown errors

---

## Error Hierarchy

```
CodedError (base)
├── DomainError
│   ├── InvariantViolationError
│   └── PartialLoadError
├── UseCaseError
│   ├── NotFoundError
│   ├── ConflictError
│   └── UnprocessableError
├── InfraError
│   ├── DbError
│   ├── NetworkError
│   ├── TimeoutError
│   └── ExternalServiceError
├── ControllerError
├── AccessDeniedError
├── InvalidRequestError
└── ObjectValidationError
```

---

## Error Codes

Each error has a predefined code:

```typescript


// Domain errors
ErrorCodes.Domain.DOMAIN_ERROR           // 'DOMAIN_ERROR'
ErrorCodes.Domain.INVARIANT_VIOLATION    // 'INVARIANT_VIOLATION'
ErrorCodes.Domain.PARTIAL_LOAD           // 'PARTIAL_LOAD'

// Use case errors
ErrorCodes.App.USE_CASE_ERROR            // 'USE_CASE_ERROR'
ErrorCodes.App.NOT_FOUND                 // 'NOT_FOUND'
ErrorCodes.App.CONFLICT                  // 'CONFLICT'
ErrorCodes.App.UNPROCESSABLE             // 'UNPROCESSABLE'

// Infrastructure errors
ErrorCodes.Infra.INFRA_ERROR             // 'INFRA_ERROR'
ErrorCodes.Infra.DB_ERROR                // 'DB_ERROR'
ErrorCodes.Infra.NETWORK_ERROR           // 'NETWORK_ERROR'
ErrorCodes.Infra.TIMEOUT_ERROR           // 'TIMEOUT_ERROR'
ErrorCodes.Infra.EXTERNAL_SERVICE_ERROR  // 'EXTERNAL_SERVICE_ERROR'

// Presentation errors
ErrorCodes.Presentation.CONTROLLER_ERROR // 'CONTROLLER_ERROR'
ErrorCodes.Presentation.ACCESS_DENIED    // 'ACCESS_DENIED'
ErrorCodes.Presentation.INVALID_REQUEST  // 'INVALID_REQUEST'

// Global errors
ErrorCodes.Global.OBJECT_VALIDATION_ERROR // 'OBJECT_VALIDATION_ERROR'
```

---

## Domain Errors

Use for business rule violations in the domain layer:

```typescript


class Order {
  addItem(item: OrderItem): void {
    if (this.status !== 'draft') {
      throw new InvariantViolationError({
        message: 'Cannot add items to a submitted order',
        code: 'ORDER_NOT_DRAFT', // Custom code
      });
    }
    // ...
  }
}
```

---

## Use Case Errors

Use for application-level failures:

```typescript

  NotFoundError,
  ConflictError,
  UnprocessableError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

class CreateUserCommand {
  async execute(input: CreateUserInput): Promise {
    const existing = await this.userRepo.findByEmail(input.email);
    if (existing) {
      throw new ConflictError({
        message: `User with email ${input.email} already exists`,
        code: 'USER_EMAIL_EXISTS', // Custom code
      });
    }
    // ...
  }
}

class GetUserQuery {
  async execute(input: GetUserInput): Promise {
    const user = await this.userRepo.findById(input.userId);
    if (!user) {
      throw new NotFoundError({
        message: `User ${input.userId} not found`,
        code: 'USER_NOT_FOUND', // Custom code
      });
    }
    return this.toOutput(user);
  }
}
```

---

## Infrastructure Errors

Use for external system failures. `BaseOutboundAdapter` automatically wraps errors:

```typescript



class UserRepository extends BaseOutboundAdapter {
  constructor(private readonly db: Database) {
    super();
  }

  // Override to customize error type
  protected createInfraError(error: unknown, methodName: string): InfraError {
    return new DbError({
      message: `Database error in ${methodName}`,
      cause: error,
    });
  }

  async findById(id: string): Promise {
    // If this throws, it's automatically wrapped in DbError
    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);
  }
}
```

---

## Presentation Errors

Use for access control and request validation:

```typescript

  AccessDeniedError,
  InvalidRequestError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Access guard
class CanEditResourceGuard {
  async guard(request: Request): Promise {
    const canEdit = await this.checkPermission(request);
    if (!canEdit) {
      throw new AccessDeniedError({
        message: 'You do not have permission to edit this resource',
      });
    }
    return { isAllowed: true };
  }
}
```

---

## Validation Errors

`ObjectValidationError` includes structured field-level errors:

```typescript


// Thrown by validators when validation fails
throw new ObjectValidationError({
  message: 'Validation failed',
  validationErrors: [
    { field: 'email', message: 'Invalid email format' },
    { field: 'password', message: 'Password must be at least 8 characters' },
  ],
});
```

---

## HTTP Status Code Mapping

Framework integrations map errors to HTTP status codes:

| Error Type | HTTP Status | Response |
|------------|-------------|----------|
| `ObjectValidationError` | 400 Bad Request | Includes validation errors |
| `InvalidRequestError` | 400 Bad Request | Includes validation errors |
| `AccessDeniedError` | 403 Forbidden | Error message |
| `NotFoundError` | 404 Not Found | Error message |
| `ConflictError` | 409 Conflict | Error message |
| `UnprocessableError` | 422 Unprocessable Entity | Error message |
| `DomainError` | 500 Internal Server Error | Masked |
| `InfraError` | 500 Internal Server Error | Masked |
| `ControllerError` | 500 Internal Server Error | Masked |
| Unknown Error | 500 Internal Server Error | Masked |

Internal errors (Domain, Infra, Controller) are masked in responses to prevent leaking implementation details.

---

## Error Handling in Controllers

`BaseController` automatically converts `ObjectValidationError` to `InvalidRequestError`:

```typescript
class MyController extends BaseController {
  // If requestMapper throws ObjectValidationError,
  // it's converted to InvalidRequestError automatically
}
```

For custom error handling, override the `pipeline` method:

```typescript
class MyController extends BaseController {
  protected async pipeline(input: Request): Promise {
    try {
      return await super.pipeline(input);
    } catch (error) {
      if (error instanceof CustomError) {
        // Custom handling
      }
      throw error;
    }
  }
}
```

---

## Framework Error Handlers

Each framework integration provides an error handler:

```typescript
// Hono

app.onError(onionErrorHandler);

// Elysia

app.error(onionErrorHandler);

// Fastify

app.setErrorHandler(onionErrorHandler);

// NestJS

@UseFilters(OnionLasagnaExceptionFilter)

```
---

# Hono Integration
> Register routes and handle errors with Hono framework.

## Installation

```bash
bun add hono
```

Import the Hono integration:

```typescript

  registerHonoRoutes,
  onionErrorHandler,
  mapErrorToHttpException,
} from '@cosmneo/onion-lasagna/backend/frameworks/hono';
```

---

## Quick Start

```typescript



const app = new Hono();

// Apply error handler
app.onError(onionErrorHandler);

// Register routes
registerHonoRoutes(app, routes);


```

---

## Registering Routes

The `registerHonoRoutes` function registers your controllers with Hono:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',  // {param} syntax converted to :param
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
  {
    metadata: {
      method: 'POST',
      path: '/users',
    },
    controller: createUserController,
    requestDtoFactory: CreateUserRequestDto.create,
  },
];

registerHonoRoutes(app, routes);
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Hono's `:param` format:

- `/users/{userId}` → `/users/:userId`
- `/orders/{orderId}/items/{itemId}` → `/orders/:orderId/items/:itemId`

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;              // Route prefix (e.g., '/api/v1')
  middlewares?: HonoMiddleware[]; // Middlewares to apply to all routes
}

// With options
registerHonoRoutes(app, routes, {
  prefix: '/api/v1',
  middlewares: [authMiddleware, loggingMiddleware],
});
```

---

## Error Handler

The `onionErrorHandler` maps domain errors to HTTP responses:

```typescript
app.onError(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ code, message, errors }` |
| `InvalidRequestError` | 400 | `{ code, message, errors }` |
| `AccessDeniedError` | 403 | `{ code, message }` |
| `NotFoundError` | 404 | `{ code, message }` |
| `ConflictError` | 409 | `{ code, message }` |
| `UnprocessableError` | 422 | `{ code, message }` |
| `DomainError` | 500 | `{ message: 'Internal Server Error' }` |
| `InfraError` | 500 | `{ message: 'Internal Server Error' }` |
| Unknown | 500 | `{ message: 'Internal Server Error' }` |

Internal errors (Domain, Infra, Controller) are masked to prevent leaking implementation details.

---

## Custom Error Handling

Use `mapErrorToHttpException` for custom error handling:

```typescript


app.onError((error, c) => {
  // Log all errors
  console.error('Error:', error);

  // Use standard mapping
  const httpException = mapErrorToHttpException(error);
  return httpException.getResponse();
});
```

---

## Controller Structure

Controllers receive the raw Hono context and should return an `HttpResponse` wrapped in a DTO:

```typescript


class GetUserController extends BaseController,
  GetUserInputDto,
  GetUserOutputDto
> {
  static create(useCase: GetUserQueryInboundPort) {
    return new GetUserController({
      requestMapper: (dto) => GetUserInputDto.fromRequest(dto),
      useCase,
      responseMapper: (output) => HttpResponseDto.ok(output.data),
    });
  }
}
```

---

## Complete Example

```typescript




// Create app
const app = new Hono();

// Middleware
app.use('*', cors());

// Error handling
app.onError(onionErrorHandler);

// Health check
app.get('/health', (c) => c.json({ status: 'ok' }));

// API routes
registerHonoRoutes(app, userRoutes, { prefix: '/api/v1' });
registerHonoRoutes(app, orderRoutes, { prefix: '/api/v1' });


```

---

## Cloudflare Workers

```typescript
// src/index.ts



const app = new Hono();

app.onError(onionErrorHandler);
registerHonoRoutes(app, routes);


```

```toml
# wrangler.toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"
```
---

# Elysia Integration
> Register routes and handle errors with Elysia framework.

## Installation

```bash
bun add elysia
```

Import the Elysia integration:

```typescript

  registerElysiaRoutes,
  onionErrorHandler,
  mapErrorToResponse,
} from '@cosmneo/onion-lasagna/backend/frameworks/elysia';
```

---

## Quick Start

```typescript



const app = new Elysia()
  .error(onionErrorHandler)
  .use(registerElysiaRoutes(routes));

app.listen(3000);
```

---

## Registering Routes

The `registerElysiaRoutes` function returns an Elysia plugin:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
];

const app = new Elysia()
  .use(registerElysiaRoutes(routes));
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Elysia's `:param` format.

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;
  middlewares?: ElysiaMiddleware[];
}

const app = new Elysia()
  .use(registerElysiaRoutes(routes, {
    prefix: '/api/v1',
    middlewares: [authMiddleware],
  }));
```

---

## Error Handler

The `onionErrorHandler` is a function that handles errors:

```typescript
const app = new Elysia()
  .error(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ code, message, errors }` |
| `InvalidRequestError` | 400 | `{ code, message, errors }` |
| `AccessDeniedError` | 403 | `{ code, message }` |
| `NotFoundError` | 404 | `{ code, message }` |
| `ConflictError` | 409 | `{ code, message }` |
| `UnprocessableError` | 422 | `{ code, message }` |
| Internal errors | 500 | `{ message: 'Internal Server Error' }` |

---

## Custom Error Handling

Use `mapErrorToResponse` for custom handling:

```typescript


const app = new Elysia()
  .error(({ error }) => {
    console.error('Error:', error);

    const { statusCode, body } = mapErrorToResponse(error);
    return new Response(JSON.stringify(body), {
      status: statusCode,
      headers: { 'Content-Type': 'application/json' },
    });
  });
```

---

## Complete Example

```typescript




const app = new Elysia()
  .use(cors())
  .error(onionErrorHandler)
  .get('/health', () => ({ status: 'ok' }))
  .use(registerElysiaRoutes(userRoutes, { prefix: '/api/v1' }))
  .use(registerElysiaRoutes(orderRoutes, { prefix: '/api/v1' }));

app.listen(3000);

console.log(`Server running at http://localhost:3000`);
```
---

# Fastify Integration
> Register routes and handle errors with Fastify framework.

## Installation

```bash
bun add fastify
```

Import the Fastify integration:

```typescript

  registerFastifyRoutes,
  onionErrorHandler,
  mapErrorToResponse,
} from '@cosmneo/onion-lasagna/backend/frameworks/fastify';
```

---

## Quick Start

```typescript



const app = Fastify();

// Apply error handler
app.setErrorHandler(onionErrorHandler);

// Register routes
registerFastifyRoutes(app, routes);

app.listen({ port: 3000 });
```

---

## Registering Routes

The `registerFastifyRoutes` function registers your controllers with Fastify:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
];

registerFastifyRoutes(app, routes);
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Fastify's `:param` format.

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;
  middlewares?: FastifyMiddleware[];
}

registerFastifyRoutes(app, routes, {
  prefix: '/api/v1',
  middlewares: [authMiddleware],
});
```

---

## Error Handler

The `onionErrorHandler` maps domain errors to HTTP responses:

```typescript
app.setErrorHandler(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ code, message, errors }` |
| `InvalidRequestError` | 400 | `{ code, message, errors }` |
| `AccessDeniedError` | 403 | `{ code, message }` |
| `NotFoundError` | 404 | `{ code, message }` |
| `ConflictError` | 409 | `{ code, message }` |
| `UnprocessableError` | 422 | `{ code, message }` |
| Internal errors | 500 | `{ message: 'Internal Server Error' }` |

---

## Custom Error Handling

Use `mapErrorToResponse` for custom handling:

```typescript


app.setErrorHandler((error, request, reply) => {
  console.error('Error:', error);

  const { statusCode, body } = mapErrorToResponse(error);
  reply.status(statusCode).send(body);
});
```

---

## Complete Example

```typescript




const app = Fastify({ logger: true });

// Plugins
await app.register(cors);

// Error handling
app.setErrorHandler(onionErrorHandler);

// Health check
app.get('/health', () => ({ status: 'ok' }));

// API routes
registerFastifyRoutes(app, userRoutes, { prefix: '/api/v1' });
registerFastifyRoutes(app, orderRoutes, { prefix: '/api/v1' });

// Start
try {
  await app.listen({ port: 3000 });
  console.log('Server running at http://localhost:3000');
} catch (err) {
  app.log.error(err);
  process.exit(1);
}
```

---

## Type Providers

Fastify's type system works with the integration:

```typescript



const app = Fastify().withTypeProvider();
```
---

# NestJS Integration
> Use onion-lasagna patterns with NestJS framework.

## Installation

```bash
bun add @nestjs/core @nestjs/common @nestjs/platform-express
```

Import the NestJS integration:

```typescript

  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
  BaseNestController,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';
```

---

## Quick Start

```typescript


  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)
@UseInterceptors(OnionLasagnaResponseInterceptor)

  constructor(private readonly getUserQuery: GetUserQueryInboundPort) {}

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = GetUserRequestDto.create(request);
    return this.getUserQuery.execute(dto);
  }
}
```

---

## @OnionLasagnaRequest Decorator

Extracts an `HttpRequest` object from the NestJS request:

```typescript



@Get(':id')
async getItem(@OnionLasagnaRequest() request: HttpRequest) {
  // request contains: pathParams, queryParams, body, headers
}
```

The `HttpRequest` structure:

```typescript
interface HttpRequest {
  pathParams: Record;
  queryParams: Record;
  body: unknown;
  headers: Record;
  rawRequest?: unknown;  // Original NestJS request
}
```

---

## OnionLasagnaExceptionFilter

Maps domain errors to HTTP responses:

```typescript



// Apply to controller
@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)


// Or apply globally in main.ts
app.useGlobalFilters(new OnionLasagnaExceptionFilter());
```

### Error Mapping

| Error Type | HTTP Status |
|------------|-------------|
| `ObjectValidationError` | 400 |
| `InvalidRequestError` | 400 |
| `AccessDeniedError` | 403 |
| `NotFoundError` | 404 |
| `ConflictError` | 409 |
| `UnprocessableError` | 422 |
| Internal errors | 500 |

---

## OnionLasagnaResponseInterceptor

Extracts `HttpResponse` data from controller returns:

```typescript



@Controller('users')
@UseInterceptors(OnionLasagnaResponseInterceptor)


// Or apply globally
app.useGlobalInterceptors(new OnionLasagnaResponseInterceptor());
```

This allows controllers to return `HttpResponse` objects and have them automatically unwrapped.

---

## BaseNestController

A base class for NestJS controllers using onion patterns:

```typescript


@Controller('users')

  constructor(
    private readonly getUserQuery: GetUserQueryInboundPort,
    private readonly createUserCommand: CreateUserCommandInboundPort,
  ) {
    super();
  }

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    return this.execute(request, GetUserRequestDto, this.getUserQuery);
  }

  @Post()
  async createUser(@OnionLasagnaRequest() request: HttpRequest) {
    return this.execute(request, CreateUserRequestDto, this.createUserCommand);
  }
}
```

---

## Module Setup

```typescript





@Module({
  controllers: [UsersController],
  providers: [
    {
      provide: 'GetUserQueryInboundPort',
      useClass: GetUserQuery,
    },
    {
      provide: 'UserRepository',
      useClass: UserRepository,
    },
  ],
})

```

---

## Global Setup

Configure filters and interceptors globally in `main.ts`:

```typescript


  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global exception filter
  app.useGlobalFilters(new OnionLasagnaExceptionFilter());

  // Global response interceptor
  app.useGlobalInterceptors(new OnionLasagnaResponseInterceptor());

  await app.listen(3000);
}

bootstrap();
```

---

## Complete Example

```typescript
// users.controller.ts


  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)
@UseInterceptors(OnionLasagnaResponseInterceptor)

  constructor(
    private readonly getUserQuery: GetUserQueryInboundPort,
    private readonly createUserCommand: CreateUserCommandInboundPort,
  ) {}

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = GetUserRequestDto.create(request);
    const result = await this.getUserQuery.execute(dto);
    return HttpResponse.ok(result.data);
  }

  @Post()
  async createUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = CreateUserRequestDto.create(request);
    const result = await this.createUserCommand.execute(dto);
    return HttpResponse.created(result.data);
  }
}
```
---

# New Endpoint
> Step-by-step guide to creating a new HTTP endpoint

## Decision: Direct BC vs Orchestration

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Steps

### 1. Create Request/Response DTOs

```typescript:presentation/http/users/get-user/request.dto.ts
const getUserRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});
type GetUserRequest = z.infer;

// presentation/http/users/get-user/response.dto.ts
const getUserResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});
type GetUserResponse = z.infer;
```

### 2. Create Endpoint Metadata

```typescript:presentation/http/users/get-user/endpoint.metadata.ts

  method: 'GET' as const,
  path: '/users/:userId',
};
```

### 3. Define Inbound Port (in BC)

```typescript:app/ports/inbound/get-user.query.inbound.ts
interface GetUserQueryInboundPort {
  execute(input: GetUserInput): Promise;
}
```

### 4. Implement Use Case

```typescript:app/use-cases/queries/get-user.query.ts
class GetUserQuery implements GetUserQueryInboundPort {
  constructor(private readonly userRepo: UserReadRepositoryOutboundPort) {}

  async execute(input: GetUserInput): Promise {
    const user = await this.userRepo.findById(UserId.create(input.userId));
    if (!user) throw new UserNotFoundError(input.userId);
    return { id: user.id.value, email: user.email, name: user.name };
  }
}
```

### 5. Create Mappers

```typescript:presentation/http/users/get-user/to-use-case.mapper.ts
function toGetUserInput(request: GetUserRequest): GetUserInput {
  return { userId: request.pathParams.userId };
}

// presentation/http/users/get-user/to-response.mapper.ts
function toGetUserResponse(output: GetUserOutput): GetUserResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

### 6. Create Access Guard (if needed)

```typescript:presentation/http/users/get-user/access-guard.ts
class GetUserAccessGuard {
  async guard(request: GetUserRequest): Promise {
    // Allow any authenticated user
    return { isAllowed: true };
  }
}
```

### 7. Wire in Bootstrap

```typescript:bootstrap/user.bootstrap.ts
const userReadRepo = new UserRepository(new UserPersistence());
const getUserQuery = new GetUserQuery(userReadRepo);
```

### 8. Create Controller (CLI-generated in future)

Wire together: validate → guard → map → execute → map response.

---

## Checklist

- [ ] Request/Response DTOs created
- [ ] Endpoint metadata created
- [ ] Inbound port defined
- [ ] Use case implemented
- [ ] Mappers created
- [ ] Access guard created (if needed)
- [ ] Bootstrap wired
- [ ] Controller created (or generated)
---

# New Bounded Context
> Step-by-step guide to creating a new Bounded Context

## Structure

```
bounded-contexts/{bc-name}/
├── app/
│   ├── ports/
│   │   ├── inbound/
│   │   └── outbound/
│   └── use-cases/
│       ├── queries/
│       └── commands/
├── domain/
│   ├── aggregates/
│   ├── entities/
│   ├── value-objects/
│   └── exceptions/
└── infra/
```

---

## Steps

### 1. Create Folder Structure

Create all directories under `bounded-contexts/{bc-name}/`.

### 2. Define Domain Model

Start with aggregates and value objects:

```typescript:domain/value-objects/user-id.vo.ts
class UserId {
  private constructor(private readonly _value: string) {}
  static create(value: string): UserId { ... }
  static generate(): UserId { ... }
  get value(): string { return this._value; }
}

// domain/aggregates/user.aggregate.ts
class UserAggregate {
  static create(data: CreateUserData): UserAggregate { ... }
  static reconstitute(data: UserData): UserAggregate { ... }
}
```

### 3. Define Exceptions

```typescript:domain/exceptions/user-not-found.error.ts
class UserNotFoundError extends Error {
  constructor(userId: string) {
    super(`User not found: ${userId}`);
  }
}
```

### 4. Define Outbound Ports

```typescript:app/ports/outbound/user.repository.outbound.ts
interface UserReadRepositoryOutboundPort {
  findById(id: UserId): Promise;
}

interface UserWriteRepositoryOutboundPort {
  save(user: UserAggregate): Promise;
}
```

### 5. Define Inbound Ports

```typescript:app/ports/inbound/create-user.command.inbound.ts
interface CreateUserCommandInboundPort {
  execute(input: CreateUserInput): Promise;
}
```

### 6. Implement Use Cases

```typescript:app/use-cases/commands/create-user.command.ts
class CreateUserCommand implements CreateUserCommandInboundPort {
  constructor(
    private readonly readRepo: UserReadRepositoryOutboundPort,
    private readonly writeRepo: UserWriteRepositoryOutboundPort,
  ) {}

  async execute(input: CreateUserInput): Promise {
    const user = UserAggregate.create(input);
    await this.writeRepo.save(user);
    return { id: user.id.value };
  }
}
```

### 7. Implement Infrastructure (if BC-scoped)

```typescript:infra/implementations/user/user.repository.ts
class UserRepository implements 
  UserReadRepositoryOutboundPort, 
  UserWriteRepositoryOutboundPort 
{
  constructor(private readonly persistence: UserPersistence) {}
  // ...
}
```

---

## Checklist

- [ ] Folder structure created
- [ ] Value objects defined
- [ ] Aggregates defined
- [ ] Domain exceptions created
- [ ] Outbound ports defined
- [ ] Inbound ports defined
- [ ] Use cases implemented
- [ ] Infrastructure implemented (if BC-scoped)
---

# CLI Overview
> Planned tooling to automate common tasks

## Current State vs Future

| Task | Current | Future |
|------|---------|--------|
| Controller wiring | Manual in bootstrap | CLI generated |
| HTTP client | Manual | CLI generated |
| New endpoint | 6+ files created manually | CLI scaffolded |
| Dependency rules | Developer discipline | Linter enforced |

---

## Planned Tools

| Tool | Purpose |
|------|---------|
| **Controller Generator** | Auto-wire validate → guard → map → execute → respond |
| **HTTP Client Generator** | TypeScript-safe clients from request/response schemas |
| **Endpoint Scaffold** | Generate all files for a new endpoint |
| **Linter Rules** | Enforce one-way module deps, layer import rules |

---

## See Also

- [Controller Wiring](controller-wiring.md)
- [HTTP Client Generation](http-client-generation.md)
- [Endpoint Scaffolding](endpoint-scaffolding.md)
- [Linter Rules](linter-rules.md)
---

# Endpoint Scaffolding
> CLI command to generate all files for a new endpoint

## Command

```bash
onion-cli generate endpoint users/get-user --method GET --path /users/:userId
```

---

## Generated Files

```
presentation/http/users/get-user/
├── endpoint.metadata.ts
├── request.dto.ts
├── response.dto.ts
├── access-guard.ts
├── to-use-case.mapper.ts
└── to-response.mapper.ts
```

Plus stubs in the BC:

```
app/ports/inbound/get-user.query.inbound.ts
app/use-cases/queries/get-user.query.ts
```

---

## Options

| Flag | Description |
|------|-------------|
| `--method` | HTTP method (GET, POST, etc.) |
| `--path` | URL path with params |
| `--bc` | Target bounded context |
| `--orchestration` | Create as composition/workflow instead |
---

# Controller Wiring
> Auto-generate controllers that wire all endpoint components

## Current Manual Approach

```typescript:bootstrap/user.bootstrap.ts
const userPersistence = new UserPersistence(db);
const userRepo = new UserRepository(userPersistence);
const getUserQuery = new GetUserQuery(userRepo);
const getUserAccessGuard = new GetUserAccessGuard();

// Controller manually wires everything
class GetUserController {
  static async execute(event: APIGatewayEvent) {
    const request = parseRequest(event);

    // 1. Validate
    const validated = getUserRequestSchema.parse(request);

    // 2. Check access
    const guardResult = await getUserAccessGuard.guard(validated);
    if (!guardResult.allowed) throw new ForbiddenError();

    // 3. Map to input
    const input = toGetUserInput(validated);

    // 4. Execute
    const output = await getUserQuery.execute(input);

    // 5. Map to response
    return toGetUserResponse(output);
  }
}
```

---

## Future Generated Approach

```bash
onion-cli generate controller get-user
```

Generates a controller that:
- Reads endpoint metadata
- Wires validation, guard, mappers, use case
- Handles exception mapping
- Outputs framework-specific handler
---

# HTTP Client Generation
> Generate TypeScript-safe HTTP clients from schemas

## Goal

Frontend developers get auto-completed, type-safe API calls.

---

## Source of Truth

- `presentation/http/{resource}/{endpoint}/request.dto.ts`
- `presentation/http/{resource}/{endpoint}/response.dto.ts`

---

## Generated Output

```typescript:packages/shared/clients/http/user.client.ts

class UserClient {
  constructor(
    private readonly baseUrl: string,
    private readonly auth: AuthConfig,
  ) {}

  async getUser(userId: string): Promise {
    const response = await fetch(`${this.baseUrl}/users/${userId}`, {
      headers: this.auth.headers(),
    });
    return getUserResponseSchema.parse(await response.json());
  }

  async createUser(data: CreateUserRequest['body']): Promise {
    // ...
  }
}
```

---

## Usage

```typescript
const userClient = new UserClient('https://api.example.com', authConfig);
const user = await userClient.getUser('123');  // Fully typed!
```
---

# Linter Rules
> ESLint rules to enforce architecture constraints

## Rules

### One-Way Module Dependencies

Modules can import from each other, but only one direction.

```typescript
// ✅ OK: Module A imports from Module B


// ❌ ERROR: Module B also imports from Module A (creates cycle)

```

### Layer Import Restrictions

| From | Can Import |
|------|------------|
| BC | Shared only |
| Infrastructure | BC ports, domain, shared |
| Orchestrations | BC ports + use cases, shared |
| Presentation | All inner layers |

```typescript
// In bounded-contexts/user/
// ❌ ERROR: Cannot import from infrastructure

```

### No `implements` in Persistence/External

```typescript
// ❌ ERROR: Only implementations/ can use `implements`
class UserPersistence implements UserRepositoryOutboundPort { ... }
```

---

## Configuration

```javascript:eslint.config.js



  onionLasagnaPlugin.configs.recommended,
];
```
---

# Anti-Patterns
> What NOT to do when implementing Onion Lasagna Architecture

## Bounded Context

### ❌ Framework Code in Domain

```typescript
// BAD: Using Express in domain

class CreateUserCommand {
  execute(req: Request, res: Response) { ... }
}
```

### ❌ Environment Variables in Domain

```typescript
// BAD: Reading env vars in BC
const apiKey = process.env.API_KEY;
```

### ❌ Direct Cross-BC Import

```typescript
// BAD: Importing from another BC

```

---

## Infrastructure

### ❌ Business Logic in Repository

```typescript
// BAD: Price calculation in repository
async findWithDiscount(id: string): Promise {
  const product = await this.db.find(id);
  product.price = product.price * 0.9;  // BAD!
  return product;
}
```

### ❌ `implements` in Persistence/External

```typescript
// BAD: Persistence should NOT implement port
class UserPersistence implements UserRepositoryOutboundPort { ... }

// GOOD: Only implementations/ use `implements`
class UserRepository implements UserRepositoryOutboundPort {
  constructor(private persistence: UserPersistence) {}
}
```

---

## Presentation

### ❌ Business Logic in Access Guard

```typescript
// BAD: Custom logic in guard
async guard(request: Request): Promise {
  const discount = request.user.isVIP ? 0.2 : 0;  // BAD!
  return { allowed: true, discount };
}
```

### ❌ Business Logic in Mapper

```typescript
// BAD: Calculation in mapper
function toResponse(order: Order): OrderResponse {
  return {
    ...order,
    total: order.items.reduce((sum, i) => sum + i.price, 0),  // BAD!
  };
}
```

---

## Dependencies

### ❌ Outer Layer Import in Inner Layer

```typescript
// BAD: BC importing from Infrastructure

```

### ❌ Two-Way Module Dependencies

```typescript
// BAD: Module A imports Module B, AND Module B imports Module A
// This creates circular dependency
```

---

## Naming

### ❌ Inconsistent Port Naming

```typescript
// BAD: Missing port suffix
interface UserRepository { ... }

// GOOD
interface UserRepositoryOutboundPort { ... }
```
---
