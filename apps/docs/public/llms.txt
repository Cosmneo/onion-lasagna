# Onion Lasagna Architecture Documentation


# Philosophy
> Why this architecture and when to use it

## Core Principles

### 1. Business Logic is Framework-Free

Domain code never knows about:
- HTTP frameworks (Express, Fastify, etc.)
- Database clients (Drizzle, Prisma, etc.)
- Cloud providers
- Environment variables

**Why?** Frameworks change. Your business rules shouldn't.

### 2. Dependencies Flow Inward

```
Presentation → Infrastructure → Orchestrations → Bounded Contexts
```

Inner layers never import from outer layers.

### 3. Contracts are the Source of Truth

- **Read Models** define shared data shapes
- **Request/Response DTOs** define API contracts
- Frontend and backend share the same schemas

---

## When to Use

### Good Fit ✅
- Medium to large applications
- Multiple bounded contexts
- Complex business rules
- Long-term maintainability matters

### Not a Good Fit ❌
- Simple CRUD apps
- Prototypes / MVPs
- Minimal business logic

---

## Tradeoffs

### What You Gain
- **Testability** — Pure domain logic, easy mocking
- **Flexibility** — Swap databases, frameworks
- **Clarity** — Each layer has one job
- **Scalability** — BCs can become services

### What You Pay
- **More files** — Ports, DTOs, mappers
- **Learning curve** — New developers need onboarding
- **Indirection** — Request flows through layers
---

# Glossary
> Terms and definitions for Onion Lasagna Architecture

## Layers

**Bounded Context (BC)**
: A logical boundary with its own domain model, language, and rules. BCs don't import from each other directly.

**Orchestrations**
: Coordinates operations across multiple BCs. Three types: Compositions, Workflows, Projections.

**Infrastructure**
: Implements outbound ports. Contains persistence (databases) and external (API clients).

**Presentation**
: HTTP handlers, controllers, access guards, and mappers.

---

## Orchestration Types

**Composition**
: Read-only query that fans out to multiple BCs and aggregates results.

**Workflow**
: Command with side effects that may span multiple BCs. May include compensation logic.

**Projection**
: Denormalized read store. Can read from shared database, writes only to its own storage.

---

## Ports

**Inbound Port**
: Interface that defines how external actors interact with the BC. Implemented by use cases.

**Outbound Port**
: Interface that defines how the BC interacts with external systems. Implemented by infrastructure.

---

## Domain

**Aggregate**
: Cluster of domain objects treated as a single unit. Enforces business invariants.

**Entity**
: Domain object with unique identity that persists over time.

**Value Object (VO)**
: Immutable object defined by its attributes, not identity. Used for type safety.

---

## Data

**DTO (Data Transfer Object)**
: Object that carries data between layers. Immutable, validated at creation.

**Read Model**
: DTO optimized for display. Returned by Query Repositories.

---

## Repositories

**Query Repository**
: Returns Read Models. Optimized for display.

**Read Repository**
: Returns Aggregates. Used before modifications.

**Write Repository**
: Persists Aggregates. Returns void or ID.

---

## Presentation

**Access Guard**
: Stateless gate-keeper at controller level. Receives use cases via DI, cannot implement custom logic.

**Mapper**
: Pure function that transforms data between HTTP and use case shapes.
---

# Overview
> Layer structure, dependencies, and request flow

## Layer Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      PRESENTATION                           │
│  HTTP handlers, controllers, access guards, mappers         │
│  CAN import: All inner layers                               │
├─────────────────────────────────────────────────────────────┤
│                      INFRASTRUCTURE                         │
│  Implementations, Persistence, External                     │
│  CAN import: BC ports, domain (VOs, aggregates), shared     │
├─────────────────────────────────────────────────────────────┤
│                      ORCHESTRATIONS                         │
│  Compositions, Workflows, Projections                       │
│  CAN import: BC ports + use cases                           │
├─────────────────────────────────────────────────────────────┤
│                    BOUNDED CONTEXTS                         │
│  Domain + Use Cases + Ports                                 │
│  CAN import: Shared only (NO frameworks, NO env vars)       │
├─────────────────────────────────────────────────────────────┤
│                         SHARED                              │
│  Read Models, Enums, Generated Clients                      │
└─────────────────────────────────────────────────────────────┘
                   Dependencies flow INWARD →
```

---

## Dependency Rules

| Layer | Can Import |
|-------|------------|
| **Presentation** | Infrastructure, Orchestrations, Bounded Contexts, Shared |
| **Infrastructure** | BC ports, domain (VOs, aggregates), Shared |
| **Orchestrations** | BC ports + use cases, Shared |
| **Bounded Contexts** | Shared only |
| **Shared** | Nothing (leaf layer) |

---

## Request Flow

```
HTTP Request
    │
    ▼
Handler ─────────────────► Extracts event, generates ExecutionContext
    │
    ▼
Controller ──────────────► Validates, authorizes, maps
    │
    ▼
Use Case / Orchestration ► Business logic
    │
    ▼
Outbound Port Implementation
    │
    ▼
Persistence / External ──► Database or API call
    │
    ▼
Response bubbles back up
```

---

## Folder Structure

### Module-Based

```
packages/backend/
├── modules/{module}/
│   ├── bounded-contexts/{bc}/
│   │   ├── app/
│   │   │   ├── ports/inbound/
│   │   │   │   ├── queries/
│   │   │   │   └── commands/
│   │   │   ├── ports/outbound/
│   │   │   └── use-cases/
│   │   │       ├── queries/
│   │   │       └── commands/
│   │   ├── domain/
│   │   │   ├── aggregates/
│   │   │   ├── events/
│   │   │   └── services/
│   │   ├── infra/
│   │   │   ├── outbound-adapters/
│   │   │   ├── persistence/
│   │   │   ├── external-systems/
│   │   │   ├── schemas/
│   │   │   └── config/
│   │   └── presentation/
│   │       ├── bootstrap/
│   │       └── http/
│   ├── orchestrations/{orchestration}/
│   │   ├── app/
│   │   ├── infra/
│   │   └── presentation/
│   └── shared/
│       ├── infra/
│       ├── app/
│       └── domain/
└── shared/
    ├── infra/
    ├── app/
    └── domain/
```

### Simple

```
packages/backend/
├── bounded-contexts/{bc}/
│   ├── app/
│   ├── domain/
│   ├── infra/
│   └── presentation/
├── orchestrations/{orchestration}/
│   ├── app/
│   ├── infra/
│   └── presentation/
└── shared/
    ├── infra/
    ├── app/
    └── domain/
```
---

# Presentation
> HTTP handlers, controllers, access guards, and mappers

HTTP layer: handlers, controllers, access guards, mappers.

---

## Structure

```
presentation/
└── http/
    ├── service.metadata.ts          ← Service-level config (basePath)
    ├── resources/
    │   └── {resource}.metadata.ts   ← Resource metadata
    ├── endpoints/
    │   └── {resource}/
    │       └── {action}.metadata.ts ← Endpoint metadata
    └── {resource}/{endpoint}/
        ├── dtos.ts                  ← Request & Response DTOs
        ├── schemas.ts               ← Zod/validation schemas
        ├── mappers.ts               ← DTO transformations
        └── endpoint.metadata.ts     ← (alternative location)
```


You can organize files as `dtos.ts` + `mappers.ts` (combined) or `request.dto.ts` + `response.dto.ts` + `to-use-case.mapper.ts` + `to-response.mapper.ts` (separate). Choose one pattern and use it consistently.


---

## Route Composition

Routes are built by composing three metadata levels:

### 1. Service Metadata

Defines the base path for the entire bounded context:

```typescript:service.metadata.ts



  id: 'project-management-service',
  shortId: 'pms',
  name: 'Project Management',
  description: 'Manages projects, tasks, and statuses',
  basePath: '/api/projects',
  openApi: {
    title: 'Project Management API',
    description: 'API for managing projects',
  },
};
```

### 2. Resource Metadata

Defines a resource within the service:

```typescript:resources/projects.metadata.ts



  id: 'projects',
  shortId: 'prj',
  name: 'Projects',
  description: 'Project management endpoints',
  path: '',  // Empty = at service root
  order: 1,
  openApi: {
    tag: 'Projects',
    tagDescription: 'Project operations',
  },
};
```

### 3. Endpoint Metadata

Defines a specific endpoint:

```typescript:endpoints/projects/create-project.metadata.ts



  id: 'create-project',
  shortId: 'cp',
  name: 'createProject',
  description: 'Creates a new project',
  method: 'POST',
  path: '',  // Empty = at resource root
  openApi: {
    summary: 'Create a new project',
    successStatus: 201,
  },
};
```

### computeRoutePath

Combines metadata into a full path:

```typescript


// Result: '/api/projects'
const path = computeRoutePath(
  projectManagementServiceMetadata,  // basePath: '/api/projects'
  projectsResourceMetadata,          // path: ''
  createProjectEndpointMetadata      // path: ''
);

// For nested resources with path params
// Result: '/api/projects/{projectId}/tasks'
const tasksPath = computeRoutePath(
  projectManagementServiceMetadata,  // basePath: '/api/projects'
  tasksResourceMetadata,             // path: '/{projectId}/tasks'
  listTasksEndpointMetadata          // path: ''
);
```


Paths use `{param}` syntax which is framework-agnostic. Framework integrations convert to the appropriate format (e.g., `:param` for Hono/Express).


---

## Request/Response DTOs

These are the **source of truth** for API contracts.

```typescript:request.dto.ts
const findUserByIdRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});

type FindUserByIdRequest = z.infer;
```

```typescript:response.dto.ts
const findUserByIdResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});

type FindUserByIdResponse = z.infer;
```

---

## Access Guards

Access guards are **functions** (not classes) that determine if a request is allowed.

**Type Definition:**

```typescript
type AccessGuard = (
  request: T,
) => AccessGuardResult | Promise;

interface AccessGuardResult {
  isAllowed: boolean;
  reason?: string;
}
```

**Example:**

```typescript:access-guard.ts


// Simple guard
const requireAdmin: AccessGuard = (request) => ({
  isAllowed: request.data.role === 'admin',
  reason: 'Admin access required',
});

// Guard using a use case (via closure)
const createCanManageResourceGuard = (
  canManageQuery: CanManageResourceQueryInboundPort,
): AccessGuard => async (request) => {
  const result = await canManageQuery.execute({
    userId: request.data.userId,
    resourceId: request.data.resourceId,
  });
  return { isAllowed: result.allowed, reason: result.reason };
};
```

**Rules:**
- ✅ Functions, not classes
- ✅ Can use closures for dependency injection
- ✅ Delegate authorization logic to use cases
- ❌ Cannot implement custom business logic

---

## Mappers

Pure functions transforming between HTTP and use case shapes.

```typescript:to-use-case.mapper.ts
function toFindUserByIdInput(request: FindUserByIdRequest): FindUserByIdInput {
  return { userId: request.pathParams.userId };
}

// to-response.mapper.ts
function toFindUserByIdResponse(output: FindUserByIdOutput): FindUserByIdResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

---

## Execution Context

Generated at controller level. **Never a frontend concern.**

```typescript
// Inside controller/handler
const executionContext = {
  userId: extractUserIdFromToken(request),
  roles: extractRolesFromToken(request),
};
```

---

## Controllers

The library provides `BaseController` and `GuardedController` for building type-safe controller pipelines.

### BaseController

Simple pipeline: validate request → map to use case input → execute → map response.

```typescript


const getUserController = BaseController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
});

// Execute
const response = await getUserController.execute(requestDto);
```

### GuardedController

Extends `BaseController` with an access guard.

```typescript


const updateUserController = GuardedController.create({
  requestMapper: (req) => UpdateUserInputDto.create(req.data),
  useCase: updateUserCommand,
  responseMapper: (output) => UpdateUserResponseDto.create(output.data),
  accessGuard: async (req) => ({
    isAllowed: req.data.role === 'admin',
    reason: 'Admin access required',
  }),
});
```

### Generic Type Parameters

Both controllers use 4 generic type parameters, all extending `BaseDto`:

```typescript
class BaseController,  // HTTP request DTO
  TResponseDto extends BaseDto, // HTTP response DTO
  TInDto extends BaseDto,       // Use case input DTO
  TOutDto extends BaseDto,      // Use case output DTO
>
```

---

## Exception Handling

Controllers automatically convert `ObjectValidationError` to `InvalidRequestError`.

For framework-specific exception handling, use the error handlers from framework integrations:

```typescript
// Hono

app.onError(onionErrorHandler);

// Elysia

app.error(onionErrorHandler);

// Fastify

app.setErrorHandler(onionErrorHandler);
```
---

# Infrastructure
> Implement outbound ports with persistence and external services

Implements outbound ports. Three-tier structure.

---

## Structure

```
infra/
├── outbound-adapters/         ← Outbound port implementations (uses `implements`)
│   └── {resource}/
│       └── {resource}.repository.ts
├── persistence/               ← Raw database access (NO `implements`)
│   └── drizzle/
│       └── {resource}/
├── external-systems/          ← Raw API adapters (NO `implements`)
│   └── {service-name}/
├── schemas/                   ← Validation schemas
│   ├── use-cases/
│   │   ├── queries/{query}/
│   │   └── commands/{command}/
│   └── http/
│       └── {resource}/{endpoint}/
└── config/                    ← Configuration and environment
```

---

## Key Rule

**Only `outbound-adapters/` uses the `implements` keyword.**

Persistence and external-systems are plain classes that the adapters orchestrate.

---

## Example

### Persistence (Raw Database)

```typescript:persistence/drizzle/user/user.persistence.ts
class UserPersistence {
  async findById(id: string): Promise {
    return db.select().from(users).where(eq(users.id, id)).limit(1)[0];
  }

  async insert(data: UserRow): Promise {
    await db.insert(users).values(data);
  }
}
```

### Outbound Adapter (Port Implementation)

```typescript:outbound-adapters/user/user.repository.ts


class UserRepository
  extends BaseOutboundAdapter
  implements UserRepositoryOutboundPort
{
  constructor(private readonly persistence: UserPersistence) {
    super();
  }

  async findById(id: UserId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return UserAggregate.reconstitute(row);  // Hydrates aggregate
  }

  async save(user: UserAggregate): Promise {
    await this.persistence.insert({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Extending `BaseOutboundAdapter` automatically wraps all methods with error handling, converting any thrown errors to `InfraError`.

---

## Shared Infrastructure Scoping

| Scope | Location | Use When |
|-------|----------|----------|
| Global | `/packages/backend/shared/infra/` | Shared across all modules |
| Module | `/modules/{module}/shared/infra/` | Shared across BCs in one module |
| BC | `/bounded-contexts/{bc}/infra/` | Scoped to single BC |

Simple systems can share a single database + ORM via `shared/infra/`.

---

## Infrastructure Mappers

For complex domain-to-persistence mappings, use dedicated mapper objects:

```typescript:persistence/drizzle/mappers/project.mapper.ts






  /**
   * Converts database rows to domain aggregate
   */
  toDomain(row: ProjectRow, statusRows: StatusRow[], taskRows: TaskRow[]): Project {
    const statuses = statusRows.map(StatusMapper.toDomain);
    const tasks = taskRows.map(TaskMapper.toDomain);

    return Project.reconstitute(
      ProjectId.create(row.id),
      ProjectName.create(row.name),
      ProjectDescription.create(row.description ?? ''),
      statuses,
      tasks,
      row.createdAt,
      row.version,
    );
  },

  /**
   * Converts domain aggregate to database row
   */
  toRow(project: Project): NewProjectRow {
    return {
      id: project.id.value,
      name: project.name.value,
      description: project.description.value || null,
      createdAt: project.createdAt,
      version: project.version,
    };
  },
};
```

### Using Mappers in Repositories

```typescript:outbound-adapters/persistence/drizzle/project/project.repository.adapter.ts



class ProjectRepository extends BaseOutboundAdapter implements ProjectRepositoryPort {
  async findById(id: ProjectId): Promise {
    const row = await this.db.query.projects.findFirst({
      where: eq(projects.id, id.value),
    });
    if (!row) return null;

    const statusRows = await this.db.query.statuses.findMany({
      where: eq(statuses.projectId, id.value),
    });
    const taskRows = await this.db.query.tasks.findMany({
      where: eq(tasks.projectId, id.value),
    });

    return ProjectMapper.toDomain(row, statusRows, taskRows);
  }

  async save(project: Project): Promise {
    const row = ProjectMapper.toRow(project);
    await this.db.insert(projects).values(row).onConflictDoUpdate({
      target: projects.id,
      set: row,
    });

    // Save child entities
    for (const status of project.statuses) {
      const statusRow = StatusMapper.toRow(status, project.id.value);
      await this.db.insert(statuses).values(statusRow).onConflictDoUpdate({
        target: statuses.id,
        set: statusRow,
      });
    }
  }
}
```

### Mapper Directory Structure

```
infra/
└── outbound-adapters/
    └── persistence/
        └── drizzle/
            ├── mappers/                ← Shared mappers
            │   ├── project.mapper.ts
            │   ├── status.mapper.ts
            │   └── task.mapper.ts
            ├── project/                ← Repository implementations
            │   └── project.repository.adapter.ts
            └── project-query/
                └── project-query.repository.adapter.ts
```


**toDomain** converts persistence (row) → domain (aggregate/entity)
**toRow** converts domain (aggregate/entity) → persistence (row)


---

## Aggregate Hydration

Repositories are responsible for hydrating aggregates using `Aggregate.reconstitute()`.

**Prefer partial loading** over full loading when possible.

---

## Environment Variables

- ❌ **Prohibited** in Bounded Contexts
- ✅ **Allowed** in Infrastructure (persistence, external, implementations)
---

# Orchestrations
> Coordinate operations across multiple Bounded Contexts

Coordinates operations across multiple Bounded Contexts.

---

## When to Use

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Three Types

| Type | Purpose | Example |
|------|---------|---------|
| **Composition** | Read-only, multi-BC query | GET order with customer + products |
| **Workflow** | Write, multi-BC command | Checkout: order + inventory + payment |
| **Projection** | Denormalized read store | Dashboard aggregating multiple BCs |

---

## Structure

Each orchestration is self-contained with its own layers:

```
orchestrations/{orchestration-name}/
├── app/
│   ├── inbound/
│   │   ├── compositions/
│   │   │   └── {composition}/
│   │   ├── workflows/
│   │   │   └── {workflow}/
│   │   └── projections/
│   │       └── {projection}/
│   └── outbound/
├── infra/
│   ├── outbound-adapters/
│   ├── persistence/
│   └── schemas/
└── presentation/
    ├── bootstrap/
    └── http/
```

**Note:** Each orchestration has its own presentation layer for HTTP endpoints specific to that orchestration.

---

## Composition

```typescript:compositions/use-cases/get-order-details.composition.ts
class GetOrderDetailsComposition implements GetOrderDetailsCompositionInboundPort {
  constructor(
    orderQueryRepo: OrderQueryRepositoryOutboundPort,
    customerQueryRepo: CustomerQueryRepositoryOutboundPort,
  ) {
    this.findOrderQuery = new FindOrderByIdQuery(orderQueryRepo);
    this.findCustomerQuery = new FindCustomerByIdQuery(customerQueryRepo);
  }

  async execute(input: GetOrderDetailsInput): Promise {
    const order = await this.findOrderQuery.execute({ orderId: input.orderId });
    const customer = await this.findCustomerQuery.execute({ customerId: order.customerId });
    return { order, customer };
  }
}
```

---

## Workflow

```typescript:workflows/use-cases/process-checkout.workflow.ts
class ProcessCheckoutWorkflow implements ProcessCheckoutWorkflowInboundPort {
  async execute(input: ProcessCheckoutInput): Promise {
    const order = await this.createOrderCommand.execute({ ... });
    
    try {
      await this.reserveInventoryCommand.execute({ orderId: order.id });
      await this.processPaymentCommand.execute({ orderId: order.id });
      return { orderId: order.id, status: 'COMPLETED' };
    } catch (error) {
      await this.cancelOrderCommand.execute({ orderId: order.id });
      throw error;
    }
  }
}
```

---

## Projection

Projections have their own infrastructure layer for denormalized storage.

**Rules:**
- CAN read from shared database
- CAN write only to its own denormalized storage
- For simple systems with shared DB, may not need separate storage

```typescript:projections/use-cases/user-dashboard.projection.ts
class UserDashboardProjection implements UserDashboardProjectionInboundPort {
  async execute(input: UserDashboardInput): Promise {
    // Reads from multiple BCs, returns aggregated view
  }
}
```

---

## Naming

| Type | Interface | File |
|------|-----------|------|
| Composition | `{Name}CompositionInboundPort` | `.composition.ts` |
| Workflow | `{Name}WorkflowInboundPort` | `.workflow.ts` |
| Projection | `{Name}ProjectionInboundPort` | `.projection.ts` |
---

# Bounded Contexts
> Pure domain logic with ports and use cases

Pure domain logic, completely framework-free.

---

## Structure

```
bounded-contexts/{bc-name}/
├── bootstrap/                   ← Dependency wiring (at BC root!)
│   ├── index.ts                 ← Main orchestration
│   ├── adapters.bootstrap.ts
│   ├── use-cases.bootstrap.ts
│   ├── validators.bootstrap.ts
│   ├── controller.bootstrap.ts
│   └── routes.bootstrap.ts
├── app/
│   ├── ports/
│   │   ├── inbound/
│   │   │   ├── {resource}/      ← Ports grouped by resource
│   │   │   │   ├── create-{resource}.command.port.ts
│   │   │   │   ├── get-{resource}.query.port.ts
│   │   │   │   └── list-{resources}.query.port.ts
│   │   └── outbound/            ← Repository interfaces
│   └── use-cases/
│       └── {resource}/          ← Use cases grouped by resource
│           ├── create-{resource}.command.ts
│           ├── get-{resource}.query.ts
│           └── list-{resources}.query.ts
├── domain/
│   ├── aggregates/
│   │   └── {aggregate}/
│   │       └── policies/
│   ├── entities/
│   ├── value-objects/
│   ├── events/                  ← Domain events
│   ├── services/                ← Domain services
│   └── exceptions/
├── infra/
│   └── outbound-adapters/       ← Port implementations
│       └── persistence/
│           └── drizzle/
│               ├── mappers/     ← Domain ↔ persistence mappers
│               └── {resource}/  ← Repository implementations
└── presentation/                ← BC-specific HTTP layer
    └── http/
        ├── service.metadata.ts
        ├── resources/           ← Resource metadata
        ├── endpoints/           ← Endpoint metadata
        └── {resource}/{endpoint}/
            ├── dtos.ts          ← Request/Response DTOs
            ├── schemas.ts       ← Validation schemas
            ├── mappers.ts       ← DTO transformations
            └── endpoint.metadata.ts
```


The **bootstrap** folder is at the BC root, not under presentation. See [Bootstrap Pattern](/docs/patterns/bootstrap) for details.


---

## Golden Rules

1. **NO framework imports**
2. **NO environment variables**
3. **NO direct cross-BC imports**
4. **CAN import** from domain (VOs, aggregates) into infra

---

## Inbound Ports

Interfaces for use cases. Implemented by queries and commands.

```typescript:ports/inbound/queries/find-user-by-id.port.ts
interface FindUserByIdQueryInboundPort {
  execute(input: FindUserByIdInputDto): Promise;
}
```

### Naming Conventions

Two patterns are acceptable:

**Full naming (explicit):**
| Type | Interface | File |
|------|-----------|------|
| Query | `{Name}QueryInboundPort` | `{resource}/{name}.query.port.ts` |
| Command | `{Name}CommandInboundPort` | `{resource}/{name}.command.port.ts` |

**Short naming (concise):**
| Type | Interface | File |
|------|-----------|------|
| Query | `{Name}Port` | `{resource}/{name}.query.port.ts` |
| Command | `{Name}Port` | `{resource}/{name}.command.port.ts` |


Choose one convention and use it consistently throughout your project. The short naming works well when file names already indicate the type (`.query.port.ts` vs `.command.port.ts`).


---

## Outbound Ports

Interfaces for external dependencies. Implemented by infrastructure.

```typescript:ports/outbound/user.repository.outbound.ts
interface UserRepositoryOutboundPort {
  findById(id: UserId): Promise;
  save(user: User): Promise;
}
```

---

## Use Cases

Implement inbound ports using `BaseInboundAdapter` for automatic error handling.

```typescript:use-cases/queries/find-user-by-id.use-case.ts


class FindUserByIdQuery
  extends BaseInboundAdapter
  implements FindUserByIdQueryInboundPort
{
  constructor(private readonly userRepo: UserRepositoryOutboundPort) {
    super();
  }

  protected async handle(input: FindUserByIdInputDto): Promise {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    return FindUserByIdOutputDto.create({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Implement `handle()` (protected) instead of `execute()`. The `BaseInboundAdapter` provides `execute()` with automatic error wrapping.

---

## Domain

### Aggregates

```typescript
class UserAggregate {
  private constructor(
    private readonly _id: UserId,
    private _email: string,
    private _name: string,
  ) {}

  static create(data: CreateUserData): UserAggregate { ... }
  static reconstitute(data: UserData): UserAggregate { ... }
}
```

### Value Objects

```typescript
class UserId {
  private constructor(private readonly _value: string) {}
  static create(value: string): UserId { ... }
  static generate(): UserId { ... }
  get value(): string { return this._value; }
}
```

See [Aggregates](/docs/patterns/aggregates) and [Value Objects](/docs/patterns/value-objects) for details.
---

# DTOs
> Data Transfer Objects for carrying data between layers. Immutable, validated at creation.

## Types

| DTO | Purpose | Location |
|-----|---------|----------|
| **Request DTO** | HTTP request shape | `presentation/http/{endpoint}/request.dto.ts` |
| **Response DTO** | HTTP response shape | `presentation/http/{endpoint}/response.dto.ts` |
| **Input DTO** | Use case input | `app/ports/inbound/{use-case}/` |
| **Output DTO** | Use case output | `app/ports/inbound/{use-case}/` |

---

## BaseDto Class

All DTOs extend `BaseDto` which provides:
- Immutable data access via `.data` getter
- Automatic validation at construction
- Support for skipping validation when reconstituting from trusted sources

```typescript




// Define your schema
const createUserRequestSchema = z.object({
  body: z.object({
    email: z.string().email(),
    name: z.string().min(1).max(100),
    password: z.string().min(8),
  }),
});

type CreateUserRequestData = z.infer;

// Create a DTO class extending BaseDto
class CreateUserRequestDto extends BaseDto {
  private constructor(data: CreateUserRequestData) {
    super(data, createZodValidator(createUserRequestSchema));
  }

  static create(data: unknown): CreateUserRequestDto {
    // Validates and throws ObjectValidationError if invalid
    return new CreateUserRequestDto(data as CreateUserRequestData);
  }

  // Convenience getters
  get email(): string {
    return this.data.body.email;
  }

  get name(): string {
    return this.data.body.name;
  }
}
```

---

## Use Case DTOs

Input and output DTOs follow the same pattern:

```typescript
const createUserInputSchema = z.object({
  email: z.string().email(),
  name: z.string(),
  hashedPassword: z.string(),
});

type CreateUserInputData = z.infer;

class CreateUserInputDto extends BaseDto {
  private constructor(data: CreateUserInputData) {
    super(data, createZodValidator(createUserInputSchema));
  }

  static create(data: unknown): CreateUserInputDto {
    return new CreateUserInputDto(data as CreateUserInputData);
  }
}
```

---

## Skipping Validation

Use `SKIP_DTO_VALIDATION` when reconstituting from trusted sources (e.g., database, internal mapping):

```typescript
class UserOutputDto extends BaseDto {
  private constructor(data: UserOutputData, skipValidation = false) {
    super(data, skipValidation ? SKIP_DTO_VALIDATION : createZodValidator(schema));
  }

  static create(data: unknown): UserOutputDto {
    return new UserOutputDto(data as UserOutputData);
  }

  // For internal use when data is already validated
  static fromTrusted(data: UserOutputData): UserOutputDto {
    return new UserOutputDto(data, true);
  }
}
```

---

## Other Validators

The library supports multiple validators. Replace the Zod validator with your preferred choice:

```typescript
// ArkType



const schema = type({ email: 'string.email', name: 'string' });
super(data, createArkTypeValidator(schema));

// Valibot



const schema = v.object({ email: v.pipe(v.string(), v.email()), name: v.string() });
super(data, createValibotValidator(schema));

// TypeBox



const schema = Type.Object({ email: Type.String({ format: 'email' }), name: Type.String() });
super(data, createTypeBoxValidator(schema));
```

---

## Validation Errors

When validation fails, an `ObjectValidationError` is thrown with structured field-level errors:

```typescript
try {
  const dto = CreateUserRequestDto.create(invalidData);
} catch (error) {
  if (error instanceof ObjectValidationError) {
    // error.validationErrors is an array of { field: string; message: string }
    console.log(error.validationErrors);
    // [{ field: 'body.email', message: 'Invalid email format' }]
  }
}
```

Controllers automatically convert `ObjectValidationError` to `InvalidRequestError` with a 400 status code.

---

## Centralized Validators (Recommended)

For larger projects, create validators in a central bootstrap file and inject them:

```typescript:bootstrap/validators.bootstrap.ts



// Create validators once, reuse everywhere


```

Then inject into mappers:

```typescript:presentation/http/projects/create-project/mappers.ts



// Request mapper - validator injected at runtime

  request: CreateProjectRequestDto,
  validator: DtoValidator,
): CreateProjectInputDto {
  return new CreateProjectInputDto(
    {
      name: request.data.body.name,
      description: request.data.body.description,
    },
    validator,  // Validator injected here
  );
}

// Response mapper with validator

  output: CreateProjectOutputDto,
  validator: DtoValidator,
): CreateProjectResponseDto {
  return new CreateProjectResponseDto(
    { statusCode: 201, body: { projectId: output.data.projectId } },
    validator,
  );
}
```

Wire in controllers:

```typescript:bootstrap/controller.bootstrap.ts



const createProjectController = BaseController.create({
  // Input already validated at HTTP layer, skip re-validation
  requestMapper: (req: CreateProjectRequestDto) =>
    createProjectToInputMapper(req, SKIP_DTO_VALIDATION),
  useCase: createProjectUseCase,
  // Response needs validation before sending to client
  responseMapper: (out: CreateProjectOutputDto) =>
    createProjectToResponseMapper(out, createProjectResponseValidator),
});
```


**When to skip validation:**
- Request → Input mapping: Request DTO already validated at HTTP boundary
- Internal mappings: Data comes from trusted sources (database, other validated DTOs)

**When to validate:**
- Response → HTTP: Ensure response matches expected schema before sending
- External data: Data from third-party APIs or user input


---

## DTO vs Value Object

| Aspect | DTO | Value Object |
|--------|-----|--------------|
| **Purpose** | Transfer data | Represent domain concept |
| **Location** | Presentation / App layer | Domain layer |
| **Behavior** | Minimal (data access) | May have methods |
| **Identity** | None | Compared by value |
| **Base Class** | `BaseDto` | `BaseValueObject` |
---

# Value Objects
> Immutable objects defined by their attributes, not identity. Used for type safety and validation.

## BaseValueObject

All value objects extend `BaseValueObject` and validate in their `create()` factory method:

```typescript



class Email extends BaseValueObject {
  private static readonly EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

  static create(value: Email['value']): Email {
    if (!Email.EMAIL_REGEX.test(value)) {
      throw new InvariantViolationError({
        message: 'Invalid email format',
        code: 'INVALID_EMAIL',
      });
    }
    return new Email(value);
  }

  get domain(): string {
    return this.value.split('@')[1];
  }
}
```

Key features:
- **Immutable**: Value is set at construction and cannot be changed
- **Self-validating**: Validation runs in `create()` before construction
- **Comparable**: Built-in `equals()` method with deep equality
- **Type inference**: Use `ClassName['value']` for input type

---

## Built-in Value Objects

The library provides base value objects you can extend:

### Text Types

```typescript

  BaseTextVo,        // Configurable text with static constraints
  BaseShortTextVo,   // 1-100 characters
  BaseMediumTextVo,  // 1-500 characters
  BaseLongTextVo,    // 1-5000 characters
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Create custom text VO with constraints
class ProductName extends BaseTextVo {
  static override defaultMinLength = 1;
  static override defaultMaxLength = 50;
}

class SkuCode extends BaseTextVo {
  static override defaultMinLength = 3;
  static override defaultMaxLength = 20;
  static override defaultPattern = /^[A-Z0-9-]+$/;
}
```


Text VOs use `new this(value)` internally, so subclass instances are created correctly at runtime. However, TypeScript still infers the return type as the base class. For strict type safety, you can override `create()`:

```typescript
class ProductName extends BaseTextVo {
  static override defaultMinLength = 1;
  static override defaultMaxLength = 50;

  static override create(value: ProductName['value']): ProductName {
    // Let parent validate, then cast to correct type
    BaseTextVo.create.call(this, value);
    return new ProductName(value);
  }
}
```


### Identifiers

```typescript

  BaseUuidV4Vo,  // UUID v4 format (random)
  BaseUuidV7Vo,  // UUID v7 format (time-ordered)
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Usage
const id = BaseUuidV4Vo.generate();           // Generate new
const parsed = BaseUuidV4Vo.create(uuidStr);  // Validate existing
```

### Contact

```typescript


const email = BaseEmailVo.create('user@example.com');
```

### Pagination

```typescript


const page = BasePaginationVo.create({ page: 1, pageSize: 20 });

// Properties
page.page;      // 1
page.pageSize;  // 20
page.offset;    // 0 (calculated: (page - 1) * pageSize)

// Custom max page size
class AdminPagination extends BasePaginationVo {
  static override get maxPageSize(): number {
    return 500;
  }
}
```

### Auditing

```typescript

  BaseAuditByVo,    // createdBy, updatedBy (optional UUIDs)
  BaseAuditOnVo,    // createdAt, updatedAt (with invariant check)
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Create with current timestamp
const auditOn = BaseAuditOnVo.now();

// Create with specific dates
const auditOn = BaseAuditOnVo.create({
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-15'),
});

// Update timestamp (returns new immutable instance)
const updated = auditOn.update();
```

**Note**: `BaseAuditOnVo` enforces that `updatedAt` cannot be before `createdAt`.

---

## Creating Custom Value Objects

### Simple Identifier

```typescript



class OrderId extends BaseUuidV7Vo {
  // Override generate() to return correct type
  static override generate(): OrderId {
    return new OrderId(v7());
  }

  // IMPORTANT: Override create() to return correct type
  static override create(value: OrderId['value']): OrderId {
    const validated = BaseUuidV7Vo.create(value);
    return new OrderId(validated.value);
  }
}
```


**Always override `create()` for UUID subclasses.** Without this override, `OrderId.create(uuid)` returns `BaseUuidV7Vo` instead of `OrderId`, breaking type safety and `instanceof` checks.


### Value Object with Custom Validation

```typescript



class PhoneNumber extends BaseValueObject {
  private static readonly PHONE_REGEX = /^\+[1-9]\d{1,14}$/;

  static create(value: PhoneNumber['value']): PhoneNumber {
    if (!PhoneNumber.PHONE_REGEX.test(value)) {
      throw new InvariantViolationError({
        message: 'Invalid phone number format (E.164 required)',
        code: 'INVALID_PHONE',
      });
    }
    return new PhoneNumber(value);
  }

  get countryCode(): string {
    return this.value.slice(1, 3);
  }
}
```

### Composite Value Object

```typescript



interface AddressData {
  street: string;
  city: string;
  postalCode: string;
  country: string;
}

class Address extends BaseValueObject {
  static create(data: Address['value']): Address {
    if (!data.street || data.street.trim().length === 0) {
      throw new InvariantViolationError({
        message: 'Street is required',
        code: 'INVALID_ADDRESS',
      });
    }
    if (!data.country || data.country.length !== 2) {
      throw new InvariantViolationError({
        message: 'Country must be 2-letter ISO code',
        code: 'INVALID_COUNTRY',
      });
    }
    return new Address(data);
  }

  get street(): string { return this.value.street; }
  get city(): string { return this.value.city; }
  get fullAddress(): string {
    return `${this.value.street}, ${this.value.city}, ${this.value.country}`;
  }
}
```

### Enum-like Value Object

```typescript


type OrderStatusValue = 'pending' | 'confirmed' | 'shipped' | 'cancelled';

class OrderStatus extends BaseValueObject {
  static pending(): OrderStatus {
    return new OrderStatus('pending');
  }

  static confirmed(): OrderStatus {
    return new OrderStatus('confirmed');
  }

  static shipped(): OrderStatus {
    return new OrderStatus('shipped');
  }

  static cancelled(): OrderStatus {
    return new OrderStatus('cancelled');
  }

  isPending(): boolean { return this.value === 'pending'; }
  isShipped(): boolean { return this.value === 'shipped'; }
  isModifiable(): boolean {
    return this.isPending() || this.value === 'confirmed';
  }
}
```

---

## Equality Comparison

`BaseValueObject` provides deep equality via `equals()`:

```typescript
const email1 = BaseEmailVo.create('user@example.com');
const email2 = BaseEmailVo.create('user@example.com');
const email3 = BaseEmailVo.create('other@example.com');

email1.equals(email2); // true (same value)
email1.equals(email3); // false (different value)
```

The comparison handles:
- Primitive values
- Nested objects
- Arrays
- Date objects

---

## Rules

- Use factory methods (`create`, `generate`) - never call constructor directly
- Validate in `create()` and throw `InvariantViolationError` for invalid data
- Use `ClassName['value']` for type inference in create parameters
- Add convenience getters for derived values
- Extend built-in VOs when possible (BaseEmailVo, BaseUuidV7Vo, etc.)
- Don't mutate after construction
- Don't use for complex objects (use Entities/Aggregates)
---

# Aggregates
> Entity clusters treated as a single unit. Enforce business invariants and emit domain events.

## BaseEntity and BaseAggregateRoot

The library provides base classes for entities and aggregates:

```typescript

  BaseEntity,
  BaseAggregateRoot,
  BaseDomainEvent,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

---

## BaseEntity

Entities have identity and can be compared by ID:

```typescript
abstract class BaseEntity,
  TProps extends object,
> {
  private readonly _id: TId;
  private readonly _version: number;
  protected _props: TProps;

  // Public API
  get id(): TId;
  get version(): number;
  equals(other: BaseEntity): boolean;

  // Protected (for subclasses)
  protected get props(): TProps;
  protected idEquals(a: TId, b: TId): boolean;
  protected nextVersion(): number;
}
```

---

## BaseAggregateRoot

Aggregates extend `BaseEntity` with domain event support:

```typescript
abstract class BaseAggregateRoot,
  TProps extends object,
> extends BaseEntity {
  // Add a domain event to be published
  protected addDomainEvent(event: BaseDomainEvent): void;

  // Get and clear all domain events (for publishing)
  public pullDomainEvents(): BaseDomainEvent[];

  // Peek at events without clearing
  public peekDomainEvents(): readonly BaseDomainEvent[];

  // Check if there are pending events
  public get hasDomainEvents(): boolean;

  // Clear all events (called after publishing)
  protected clearDomainEvents(): void;
}
```

---

## Creating an Aggregate

```typescript

  BaseAggregateRoot,
  BaseDomainEvent,
  InvariantViolationError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

interface OrderProps {
  customerId: CustomerId;
  items: OrderItem[];
  status: OrderStatus;
  createdAt: Date;
}

class OrderAggregate extends BaseAggregateRoot {
  private constructor(id: OrderId, props: OrderProps, version = 0) {
    super(id, props, version);
  }

  // Factory for NEW instances
  static create(data: CreateOrderData): OrderAggregate {
    const order = new OrderAggregate(
      OrderId.generate(),
      {
        customerId: CustomerId.create(data.customerId),
        items: [],
        status: OrderStatus.DRAFT,
        createdAt: new Date(),
      },
    );

    // Emit creation event
    order.addDomainEvent(new OrderCreatedEvent({
      orderId: order.id.value,
      customerId: data.customerId,
      totalAmount: 0,
    }));

    return order;
  }

  // Factory for EXISTING instances (from DB)
  static reconstitute(data: OrderData, version: number): OrderAggregate {
    return new OrderAggregate(
      OrderId.create(data.id),
      {
        customerId: CustomerId.create(data.customerId),
        items: data.items.map(OrderItem.reconstitute),
        status: data.status,
        createdAt: data.createdAt,
      },
      version,
    );
  }

  // Domain methods (enforce invariants)
  addItem(item: AddItemData): void {
    if (this._props.status !== OrderStatus.DRAFT) {
      throw new InvariantViolationError({
        message: 'Cannot add items to non-draft order',
        code: 'ORDER_NOT_EDITABLE',
      });
    }
    if (this._props.items.length >= 50) {
      throw new InvariantViolationError({
        message: 'Maximum 50 items per order',
        code: 'ORDER_LIMIT_EXCEEDED',
      });
    }

    this._props.items.push(OrderItem.create(item));
    this.addDomainEvent(new OrderItemAddedEvent({
      orderId: this.id.value,
      productId: item.productId,
      quantity: item.quantity,
    }));
  }

  submit(): void {
    if (this._props.items.length === 0) {
      throw new InvariantViolationError({
        message: 'Cannot submit empty order',
        code: 'EMPTY_ORDER',
      });
    }

    this._props.status = OrderStatus.PENDING;
    this.addDomainEvent(new OrderSubmittedEvent({
      orderId: this.id.value,
      submittedAt: new Date(),
    }));
  }

  // Getters
  get customerId(): CustomerId { return this._props.customerId; }
  get status(): OrderStatus { return this._props.status; }
  get items(): readonly OrderItem[] { return [...this._props.items]; }
}
```

---

## Domain Events

Create domain events by extending `BaseDomainEvent`. Use a **payload object** for type-safe construction:

```typescript


interface OrderCreatedPayload {
  orderId: string;
  customerId: string;
  totalAmount: number;
}

class OrderCreatedEvent extends BaseDomainEvent {
  constructor(payload: OrderCreatedPayload) {
    super('OrderCreated', payload.orderId, payload);
  }
}

interface OrderSubmittedPayload {
  orderId: string;
  submittedAt: Date;
}

class OrderSubmittedEvent extends BaseDomainEvent {
  constructor(payload: OrderSubmittedPayload) {
    super('OrderSubmitted', payload.orderId, payload);
  }
}
```


The payload object pattern ensures all event data is self-contained. The `aggregateId` is extracted from the payload rather than passed separately.


`BaseDomainEvent` provides:
- `eventId` - Unique ID for the event
- `eventName` - Name of the event
- `aggregateId` - ID of the aggregate that emitted it
- `occurredOn` - Timestamp when the event occurred
- `payload` - Event-specific data
- `toJSON()` - Serialize for storage/transport

---

## Publishing Domain Events

Use `pullDomainEvents()` to get and clear events after persisting:

```typescript
class CreateOrderCommand {
  constructor(
    private readonly orderRepo: OrderWriteRepositoryOutboundPort,
    private readonly eventPublisher: EventPublisherOutboundPort,
  ) {}

  async execute(input: CreateOrderInput): Promise {
    const order = OrderAggregate.create(input);

    // Persist first
    await this.orderRepo.save(order);

    // Then publish events (get and clear)
    const events = order.pullDomainEvents();
    await this.eventPublisher.publishAll(events);
  }
}
```

---

## Optimistic Locking

Use `version` and `nextVersion()` for optimistic concurrency:

```typescript
class OrderRepository {
  async save(order: OrderAggregate): Promise {
    const affectedRows = await this.db.query(
      `UPDATE orders SET ..., version = ? WHERE id = ? AND version = ?`,
      [order.nextVersion(), order.id.value, order.version],
    );

    if (affectedRows === 0) {
      throw new ConcurrencyError('Order was modified by another process');
    }
  }
}
```

---

## Protected Utility Methods

`BaseEntity` provides utility methods for subclasses:

### idEquals

Compares two IDs for equality using the Value Object's `equals` method:

```typescript
class OrderAggregate extends BaseAggregateRoot {
  // Use idEquals when comparing entity IDs
  hasItem(itemId: OrderItemId): boolean {
    return this._props.items.some((item) => this.idEquals(item.id, itemId));
  }
}
```

### nextVersion

Returns the next version number for optimistic locking:

```typescript
// In repository
async save(order: OrderAggregate): Promise {
  await this.db.update({
    ...this.toRow(order),
    version: order.nextVersion(),
  }).where({ id: order.id.value, version: order.version });
}
```


`nextVersion()` is protected and returns `version + 1`. Call it when persisting to implement optimistic locking.


---

## Rules

- ✅ Extend `BaseAggregateRoot` for event-sourced aggregates
- ✅ Use factory methods (`create`, `reconstitute`)
- ✅ Enforce all invariants in domain methods
- ✅ Use `InvariantViolationError` for business rule violations
- ✅ Emit domain events for state changes
- ✅ Return copies of collections from getters
- ✅ Reference other aggregates by ID only
- ✅ Use `version` for optimistic locking
- ❌ Never create with `new` directly
- ❌ Never reference other aggregates directly
- ❌ Never publish events before persisting

---

## Hydration

Repositories are responsible for hydrating aggregates:

```typescript
class OrderRepository extends BaseOutboundAdapter {
  async findById(id: OrderId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return OrderAggregate.reconstitute(row, row.version);
  }
}
```
---

# Repositories
> Provide access to aggregates and read models. Three types aligned with CQRS.

## Types

| Type | Returns | Used In |
|------|---------|---------|
| **Query Repository** | Read Models | Queries (display) |
| **Read Repository** | Aggregates | Commands (before mutation) |
| **Write Repository** | void / ID | Commands (persist) |

---

## Port Definition (Outbound)

```typescript:ports/outbound/user.repository.outbound.ts

interface UserQueryRepositoryOutboundPort {
  findPaginated(options: PaginationOptions): Promise>;
}

interface UserReadRepositoryOutboundPort {
  findById(id: UserId): Promise;
  findByEmail(email: Email): Promise;
}

interface UserWriteRepositoryOutboundPort {
  save(user: UserAggregate): Promise;
  delete(id: UserId): Promise;
}
```

---

## Implementation

Extend `BaseOutboundAdapter` for automatic error wrapping:

```typescript:infra/outbound-adapters/user/user.repository.ts


class UserRepository
  extends BaseOutboundAdapter
  implements
    UserQueryRepositoryOutboundPort,
    UserReadRepositoryOutboundPort,
    UserWriteRepositoryOutboundPort
{
  constructor(private readonly persistence: UserPersistence) {
    super();
  }

  async findById(id: UserId): Promise {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return UserAggregate.reconstitute(row);
  }

  async save(user: UserAggregate): Promise {
    await this.persistence.upsert({
      id: user.id.value,
      email: user.email.value,
      name: user.name,
    });
  }
}
```

**Note:** `BaseOutboundAdapter` automatically wraps all methods with error handling, converting any thrown errors to `InfraError`.

---

## Usage in Use Cases

```typescript
// Query use case
class FindUsersQuery {
  constructor(private readonly queryRepo: UserQueryRepositoryOutboundPort) {}

  async execute(input: FindUsersInput): Promise {
    return this.queryRepo.findPaginated(input.pagination);
  }
}

// Command use case
class CreateUserCommand {
  constructor(
    private readonly readRepo: UserReadRepositoryOutboundPort,
    private readonly writeRepo: UserWriteRepositoryOutboundPort,
  ) {}

  async execute(input: CreateUserInput): Promise {
    const existing = await this.readRepo.findByEmail(Email.create(input.email));
    if (existing) throw new EmailAlreadyExistsError(input.email);

    const user = UserAggregate.create(input);
    await this.writeRepo.save(user);
  }
}
```

---

## Rules

- ✅ Define ports in BC, implement in infrastructure
- ✅ Return Aggregates from Read Repository
- ✅ Return Read Models from Query Repository
- ✅ Hydrate aggregates in repository (not caller)
- ❌ Don't put business logic in repositories
---

# Validators
> Validator abstraction for schema validation. Supports Zod, ArkType, Valibot, and TypeBox.

## Overview

The library provides a validator abstraction layer that allows you to use your preferred validation library while maintaining consistent patterns across your codebase.

Supported validators:
- **Zod** - TypeScript-first schema validation
- **ArkType** - TypeScript's 1:1 validator
- **Valibot** - Modular, tree-shakeable validation
- **TypeBox** - JSON Schema Type Builder

---

## ObjectValidatorPort

The core abstraction is `ObjectValidatorPort`:

```typescript
interface ObjectValidatorPort {
  validateObject: ValidateObject;
  withSchema: (schema: TSchema) => BoundValidator;
}

interface BoundValidator {
  validate: (value: unknown) => T;
}
```

Each validator implementation converts validation errors to `ObjectValidationError` with structured field-level error messages.

---

## Factory Functions

Each validator exports a factory function that creates a `BoundValidator`:

```typescript
// Zod



const schema = z.object({ email: z.string().email() });
const validator = createZodValidator(schema);

// ArkType



const schema = type({ email: 'string.email' });
const validator = createArkTypeValidator(schema);

// Valibot



const schema = v.object({ email: v.pipe(v.string(), v.email()) });
const validator = createValibotValidator(schema);

// TypeBox



const schema = Type.Object({ email: Type.String({ format: 'email' }) });
const validator = createTypeBoxValidator(schema);
```

---

## Using with BaseDto

Inject validators into `BaseDto` constructors:

```typescript



class CreateUserDto extends BaseDto {
  private constructor(data: CreateUserData) {
    super(data, createZodValidator(createUserSchema));
  }

  static create(data: unknown): CreateUserDto {
    return new CreateUserDto(data as CreateUserData);
  }
}
```

---

## Dto Wrapper Classes

Each validator exports a convenience `Dto` class as a simpler alternative to extending `BaseDto`:

```typescript



const userSchema = z.object({
  name: z.string(),
  email: z.string().email(),
});

type User = z.infer;

// Create a validated DTO directly
const userDto = new Dto(userSchema, { name: 'John', email: 'john@example.com' });
console.log(userDto.data); // { name: 'John', email: 'john@example.com' }
```

Available in all validators:

```typescript




```

---

## Value Objects vs DTOs

**Value Objects** validate in their domain layer using plain TypeScript - they don't use external validators. This keeps domain invariants in the domain.

**DTOs** use validators at boundaries (API input validation) where you need schema-based validation of untrusted data.

```typescript
// Value Object - domain validation (plain TypeScript)
class Email extends BaseValueObject {
  static create(value: Email['value']): Email {
    if (!Email.EMAIL_REGEX.test(value)) {
      throw new InvariantViolationError({ message: 'Invalid email', code: 'INVALID_EMAIL' });
    }
    return new Email(value);
  }
}

// DTO - boundary validation (schema-based)
class CreateUserDto extends BaseDto {
  private constructor(data: CreateUserData) {
    super(data, createZodValidator(createUserSchema));
  }
}
```

---

## Error Handling

When validation fails, validators throw `ObjectValidationError`:

```typescript


try {
  const dto = CreateUserDto.create({ email: 'invalid' });
} catch (error) {
  if (error instanceof ObjectValidationError) {
    console.log(error.code);            // 'OBJECT_VALIDATION_ERROR'
    console.log(error.validationErrors); // [{ field: 'email', message: 'Invalid email' }]
  }
}
```

The `validationErrors` array contains structured errors:

```typescript
interface ValidationError {
  field: string;   // Dot-notation path: 'user.email', 'items[0].name'
  message: string; // Human-readable error message
}
```

---

## Swapping Validators

To switch validators, update your imports and schema definitions:

```typescript
// Before (Zod)


const schema = z.object({ name: z.string() });
const validator = createZodValidator(schema);

// After (Valibot)


const schema = v.object({ name: v.string() });
const validator = createValibotValidator(schema);
```

The `BoundValidator` interface remains the same, so your `BaseDto` classes continue working without changes.

---

## Validator Comparison

| Feature | Zod | ArkType | Valibot | TypeBox |
|---------|-----|---------|---------|---------|
| Bundle size | ~12kb | ~20kb | ~5kb | ~15kb |
| Type inference | Excellent | Excellent | Excellent | Good |
| Error messages | Detailed | Detailed | Customizable | Basic |
| Performance | Fast | Very fast | Fast | Very fast |
| Ecosystem | Large | Growing | Growing | Large |
---

# Error Handling
> Typed error hierarchy with error codes for consistent error handling across layers.

## Overview

The library provides a comprehensive error hierarchy based on `CodedError`. Each error type has a unique code for programmatic handling and maps to appropriate HTTP status codes.

---

## CodedError Base Class

All errors extend `CodedError`:

```typescript


abstract class CodedError extends Error {
  public readonly code: string;

  constructor(options: {
    message: string;
    code: string;
    cause?: unknown;
  });

  static fromError(cause: unknown): CodedError;
}
```

Key features:
- `code` - Machine-readable identifier for error handling
- `cause` - ES2022 error chaining support
- `fromError()` - Factory method for wrapping unknown errors

---

## Error Hierarchy

```
CodedError (base)
├── DomainError
│   ├── InvariantViolationError
│   └── PartialLoadError
├── UseCaseError
│   ├── NotFoundError
│   ├── ConflictError
│   └── UnprocessableError
├── InfraError
│   ├── DbError
│   ├── NetworkError
│   ├── TimeoutError
│   └── ExternalServiceError
├── ControllerError
├── AccessDeniedError
├── InvalidRequestError
└── ObjectValidationError
```

---

## Error Codes

Each error has a predefined code:

```typescript


// Domain errors
ErrorCodes.Domain.DOMAIN_ERROR           // 'DOMAIN_ERROR'
ErrorCodes.Domain.INVARIANT_VIOLATION    // 'INVARIANT_VIOLATION'
ErrorCodes.Domain.PARTIAL_LOAD           // 'PARTIAL_LOAD'

// Use case errors
ErrorCodes.App.USE_CASE_ERROR            // 'USE_CASE_ERROR'
ErrorCodes.App.NOT_FOUND                 // 'NOT_FOUND'
ErrorCodes.App.CONFLICT                  // 'CONFLICT'
ErrorCodes.App.UNPROCESSABLE             // 'UNPROCESSABLE'

// Infrastructure errors
ErrorCodes.Infra.INFRA_ERROR             // 'INFRA_ERROR'
ErrorCodes.Infra.DB_ERROR                // 'DB_ERROR'
ErrorCodes.Infra.NETWORK_ERROR           // 'NETWORK_ERROR'
ErrorCodes.Infra.TIMEOUT_ERROR           // 'TIMEOUT_ERROR'
ErrorCodes.Infra.EXTERNAL_SERVICE_ERROR  // 'EXTERNAL_SERVICE_ERROR'

// Presentation errors
ErrorCodes.Presentation.CONTROLLER_ERROR // 'CONTROLLER_ERROR'
ErrorCodes.Presentation.ACCESS_DENIED    // 'ACCESS_DENIED'
ErrorCodes.Presentation.INVALID_REQUEST  // 'INVALID_REQUEST'

// Global errors
ErrorCodes.Global.OBJECT_VALIDATION_ERROR // 'OBJECT_VALIDATION_ERROR'
```

---

## Domain Errors

Use for business rule violations in the domain layer:

```typescript


class Order {
  addItem(item: OrderItem): void {
    if (this.status !== 'draft') {
      throw new InvariantViolationError({
        message: 'Cannot add items to a submitted order',
        code: 'ORDER_NOT_DRAFT', // Custom code
      });
    }
    // ...
  }
}
```

---

## Use Case Errors

Use for application-level failures:

```typescript

  NotFoundError,
  ConflictError,
  UnprocessableError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

class CreateUserCommand {
  async execute(input: CreateUserInput): Promise {
    const existing = await this.userRepo.findByEmail(input.email);
    if (existing) {
      throw new ConflictError({
        message: `User with email ${input.email} already exists`,
        code: 'USER_EMAIL_EXISTS', // Custom code
      });
    }
    // ...
  }
}

class GetUserQuery {
  async execute(input: GetUserInput): Promise {
    const user = await this.userRepo.findById(input.userId);
    if (!user) {
      throw new NotFoundError({
        message: `User ${input.userId} not found`,
        code: 'USER_NOT_FOUND', // Custom code
      });
    }
    return this.toOutput(user);
  }
}
```

---

## Infrastructure Errors

Use for external system failures. `BaseOutboundAdapter` automatically wraps errors:

```typescript



class UserRepository extends BaseOutboundAdapter {
  constructor(private readonly db: Database) {
    super();
  }

  // Override to customize error type
  protected createInfraError(error: unknown, methodName: string): InfraError {
    return new DbError({
      message: `Database error in ${methodName}`,
      cause: error,
    });
  }

  async findById(id: string): Promise {
    // If this throws, it's automatically wrapped in DbError
    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);
  }
}
```

---

## Presentation Errors

Use for access control and request validation:

```typescript

  AccessDeniedError,
  InvalidRequestError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Access guard
class CanEditResourceGuard {
  async guard(request: Request): Promise {
    const canEdit = await this.checkPermission(request);
    if (!canEdit) {
      throw new AccessDeniedError({
        message: 'You do not have permission to edit this resource',
      });
    }
    return { isAllowed: true };
  }
}
```

---

## Validation Errors

`ObjectValidationError` includes structured field-level errors:

```typescript


// Thrown by validators when validation fails
throw new ObjectValidationError({
  message: 'Validation failed',
  validationErrors: [
    { field: 'email', message: 'Invalid email format' },
    { field: 'password', message: 'Password must be at least 8 characters' },
  ],
});
```


The HTTP response transforms `field` to `item` and `code` to `errorCode`:

```json
{
  "message": "Validation failed",
  "errorCode": "VALIDATION_ERROR",
  "errorItems": [
    { "item": "email", "message": "Invalid email format" },
    { "item": "password", "message": "Password must be at least 8 characters" }
  ]
}
```


---

## HTTP Status Code Mapping

Framework integrations map errors to HTTP status codes:

| Error Type | HTTP Status | Response |
|------------|-------------|----------|
| `ObjectValidationError` | 400 Bad Request | Includes validation errors |
| `InvalidRequestError` | 400 Bad Request | Includes validation errors |
| `AccessDeniedError` | 403 Forbidden | Error message |
| `NotFoundError` | 404 Not Found | Error message |
| `ConflictError` | 409 Conflict | Error message |
| `UnprocessableError` | 422 Unprocessable Entity | Error message |
| `DomainError` | 500 Internal Server Error | Masked |
| `InfraError` | 500 Internal Server Error | Masked |
| `ControllerError` | 500 Internal Server Error | Masked |
| Unknown Error | 500 Internal Server Error | Masked |

Internal errors (Domain, Infra, Controller) are masked in responses to prevent leaking implementation details.


**Masked errors** return HTTP 500 with `{ "message": "An unexpected error occurred", "errorCode": "INTERNAL_ERROR" }`. Your custom error message and code are not exposed to clients.


---

## Translating Domain Errors

Since `DomainError` is masked, you must translate business rule violations to `UseCaseError` in the use-case layer if you want clients to see them:

```typescript


class DeleteStatusUseCase extends BaseInboundAdapter {
  protected async handle(input: DeleteStatusInputDto): Promise {
    const project = await this.projectRepository.findById(input.data.projectId);
    if (!project) {
      throw new NotFoundError({ message: 'Project not found' });
    }

    try {
      project.deleteStatus(input.data.statusId);
    } catch (error) {
      // Translate domain errors to use-case errors
      if (error instanceof StatusNotFoundError) {
        throw new NotFoundError({
          message: error.message,
          code: 'STATUS_NOT_FOUND'
        });
      }
      if (error instanceof StatusInUseError) {
        throw new ConflictError({
          message: error.message,
          code: 'STATUS_IN_USE'
        });
      }
      if (error instanceof LastStatusError) {
        throw new UnprocessableError({
          message: error.message,
          code: 'LAST_STATUS'
        });
      }
      throw error; // Re-throw unknown errors
    }

    await this.projectRepository.save(project);
  }
}
```


**When to translate:**
- `NotFoundError` (404) - Resource doesn't exist
- `ConflictError` (409) - State conflict preventing action
- `UnprocessableError` (422) - Business rule violation

**When to keep masked:**
- Invariant violations that indicate bugs
- Internal consistency errors


---

## Error Handling in Controllers

`BaseController` automatically converts `ObjectValidationError` to `InvalidRequestError`:

```typescript
class MyController extends BaseController {
  // If requestMapper throws ObjectValidationError,
  // it's converted to InvalidRequestError automatically
}
```

For custom error handling, override the `pipeline` method:

```typescript
class MyController extends BaseController {
  protected async pipeline(input: Request): Promise {
    try {
      return await super.pipeline(input);
    } catch (error) {
      if (error instanceof CustomError) {
        // Custom handling
      }
      throw error;
    }
  }
}
```

---

## Framework Error Handlers

Each framework integration provides an error handler:

```typescript
// Hono

app.onError(onionErrorHandler);

// Elysia

app.error(onionErrorHandler);

// Fastify

app.setErrorHandler(onionErrorHandler);

// NestJS

@UseFilters(OnionLasagnaExceptionFilter)

```
---

# Hono Integration
> Register routes and handle errors with Hono framework.

## Installation

```bash
bun add hono
```

Import the Hono integration:

```typescript

  registerHonoRoutes,
  onionErrorHandler,
  mapErrorToHttpException,
} from '@cosmneo/onion-lasagna/backend/frameworks/hono';
```

---

## Quick Start

```typescript



const app = new Hono();

// Apply error handler
app.onError(onionErrorHandler);

// Register routes
registerHonoRoutes(app, routes);


```

---

## Registering Routes

The `registerHonoRoutes` function registers your controllers with Hono:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',  // {param} syntax converted to :param
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
  {
    metadata: {
      method: 'POST',
      path: '/users',
    },
    controller: createUserController,
    requestDtoFactory: CreateUserRequestDto.create,
  },
];

registerHonoRoutes(app, routes);
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Hono's `:param` format:

- `/users/{userId}` → `/users/:userId`
- `/orders/{orderId}/items/{itemId}` → `/orders/:orderId/items/:itemId`

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;                // Route prefix (e.g., '/api/v1')
  middlewares?: HonoMiddleware[]; // Middlewares to apply to all routes
}

// With options
registerHonoRoutes(app, routes, {
  prefix: '/api/v1',
  middlewares: [authMiddleware, loggingMiddleware],
});
```

---

## Contextual Routes (Protected Routes)

For routes that need authentication context (user ID, roles, etc.), use `ContextualRouteInput` with a `contextExtractor`:

```typescript

  ContextualRouteInput,
  ContextualHttpRequest,
} from '@cosmneo/onion-lasagna/backend/frameworks/hono';

// Define your auth context type
interface AuthContext {
  userId: string;
  roles: string[];
}

// Define contextual routes
const protectedRoutes: ContextualRouteInput[] = [
  {
    metadata: { method: 'GET', path: '/profile' },
    controller: getProfileController,
    requestDtoFactory: (req: ContextualHttpRequest) =>
      GetProfileRequestDto.create(req),
  },
];

// Register with contextExtractor
registerHonoRoutes(app, protectedRoutes, {
  middlewares: [authMiddleware],
  contextExtractor: (c): AuthContext => ({
    userId: c.get('userId'),
    roles: c.get('roles') ?? [],
  }),
});
```

The `contextExtractor` runs after middlewares, extracting auth data set by your auth middleware:

```typescript
// Auth middleware sets context
const authMiddleware: MiddlewareHandler = async (c, next) => {
  const token = c.req.header('Authorization');
  const payload = verifyToken(token);
  c.set('userId', payload.userId);
  c.set('roles', payload.roles);
  await next();
};
```

### Route Input Types

| Type | Use Case |
|------|----------|
| `HttpRouteInput` | Public routes (no auth context) |
| `ContextualRouteInput` | Protected routes with auth context |
| `RouteInputOrArray` | Single or array of public routes |
| `ContextualRouteInputOrArray` | Single or array of protected routes |

---

## Error Handler

The `onionErrorHandler` maps domain errors to HTTP responses:

```typescript
app.onError(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ errorCode, message, errorItems }` |
| `InvalidRequestError` | 400 | `{ errorCode, message, errorItems }` |
| `AccessDeniedError` | 403 | `{ errorCode, message }` |
| `NotFoundError` | 404 | `{ errorCode, message }` |
| `ConflictError` | 409 | `{ errorCode, message }` |
| `UnprocessableError` | 422 | `{ errorCode, message }` |
| `DomainError` | 500 | Masked |
| `InfraError` | 500 | Masked |
| Unknown | 500 | Masked |


**Masked errors** return `{ "message": "An unexpected error occurred", "errorCode": "INTERNAL_ERROR" }`. Domain and infrastructure errors are masked to prevent leaking implementation details. See [Error Handling](/docs/patterns/error-handling#translating-domain-errors) for how to expose business errors.


---

## Custom Error Handling

Use `mapErrorToHttpException` for custom error handling:

```typescript


app.onError((error, c) => {
  // Log all errors
  console.error('Error:', error);

  // Use standard mapping
  const httpException = mapErrorToHttpException(error);
  return httpException.getResponse();
});
```

---

## Controller Structure

Controllers receive the raw Hono context and should return an `HttpResponse` wrapped in a DTO:

```typescript


class GetUserController extends BaseController,
  GetUserInputDto,
  GetUserOutputDto
> {
  static create(useCase: GetUserQueryInboundPort) {
    return new GetUserController({
      requestMapper: (dto) => GetUserInputDto.fromRequest(dto),
      useCase,
      responseMapper: (output) => HttpResponseDto.ok(output.data),
    });
  }
}
```

---

## Complete Example

```typescript




// Create app
const app = new Hono();

// Middleware
app.use('*', cors());

// Error handling
app.onError(onionErrorHandler);

// Health check
app.get('/health', (c) => c.json({ status: 'ok' }));

// API routes
registerHonoRoutes(app, userRoutes, { prefix: '/api/v1' });
registerHonoRoutes(app, orderRoutes, { prefix: '/api/v1' });


```

---

## Cloudflare Workers

```typescript
// src/index.ts



const app = new Hono();

app.onError(onionErrorHandler);
registerHonoRoutes(app, routes);


```

```toml
# wrangler.toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"
```
---

# Elysia Integration
> Register routes and handle errors with Elysia framework.

## Installation

```bash
bun add elysia
```

Import the Elysia integration:

```typescript

  registerElysiaRoutes,
  onionErrorHandler,
  mapErrorToResponse,
} from '@cosmneo/onion-lasagna/backend/frameworks/elysia';
```

---

## Quick Start

```typescript



const app = new Elysia()
  .error(onionErrorHandler)
  .use(registerElysiaRoutes(routes));

app.listen(3000);
```

---

## Registering Routes

The `registerElysiaRoutes` function returns an Elysia plugin:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
];

const app = new Elysia()
  .use(registerElysiaRoutes(routes));
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Elysia's `:param` format.

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;
  middlewares?: ElysiaMiddleware[];
}

const app = new Elysia()
  .use(registerElysiaRoutes(routes, {
    prefix: '/api/v1',
    middlewares: [authMiddleware],
  }));
```

---

## Contextual Routes (Protected Routes)

For routes that need authentication context, use `ContextualRouteInput` with a `contextExtractor`:

```typescript

  ContextualRouteInput,
  ContextualHttpRequest,
} from '@cosmneo/onion-lasagna/backend/frameworks/elysia';

interface AuthContext {
  userId: string;
  roles: string[];
}

const protectedRoutes: ContextualRouteInput[] = [
  {
    metadata: { method: 'GET', path: '/profile' },
    controller: getProfileController,
    requestDtoFactory: (req: ContextualHttpRequest) =>
      GetProfileRequestDto.create(req),
  },
];

const app = new Elysia()
  .use(registerElysiaRoutes(protectedRoutes, {
    middlewares: [authMiddleware],
    contextExtractor: (ctx): AuthContext => ({
      userId: ctx.store.userId,
      roles: ctx.store.roles ?? [],
    }),
  }));
```

### Route Input Types

| Type | Use Case |
|------|----------|
| `HttpRouteInput` | Public routes (no auth context) |
| `ContextualRouteInput` | Protected routes with auth context |
| `RouteInputOrArray` | Single or array of public routes |
| `ContextualRouteInputOrArray` | Single or array of protected routes |

---

## Error Handler

The `onionErrorHandler` is a function that handles errors:

```typescript
const app = new Elysia()
  .error(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ errorCode, message, errorItems }` |
| `InvalidRequestError` | 400 | `{ errorCode, message, errorItems }` |
| `AccessDeniedError` | 403 | `{ errorCode, message }` |
| `NotFoundError` | 404 | `{ errorCode, message }` |
| `ConflictError` | 409 | `{ errorCode, message }` |
| `UnprocessableError` | 422 | `{ errorCode, message }` |
| `DomainError` | 500 | Masked |
| `InfraError` | 500 | Masked |
| Unknown | 500 | Masked |


**Masked errors** return `{ "message": "An unexpected error occurred", "errorCode": "INTERNAL_ERROR" }`. Domain and infrastructure errors are masked to prevent leaking implementation details. See [Error Handling](/docs/patterns/error-handling#translating-domain-errors) for how to expose business errors.


---

## Custom Error Handling

Use `mapErrorToResponse` for custom handling:

```typescript


const app = new Elysia()
  .error(({ error }) => {
    console.error('Error:', error);

    const { statusCode, body } = mapErrorToResponse(error);
    return new Response(JSON.stringify(body), {
      status: statusCode,
      headers: { 'Content-Type': 'application/json' },
    });
  });
```

---

## Complete Example

```typescript




const app = new Elysia()
  .use(cors())
  .error(onionErrorHandler)
  .get('/health', () => ({ status: 'ok' }))
  .use(registerElysiaRoutes(userRoutes, { prefix: '/api/v1' }))
  .use(registerElysiaRoutes(orderRoutes, { prefix: '/api/v1' }));

app.listen(3000);

console.log(`Server running at http://localhost:3000`);
```
---

# Fastify Integration
> Register routes and handle errors with Fastify framework.

## Installation

```bash
bun add fastify
```

Import the Fastify integration:

```typescript

  registerFastifyRoutes,
  onionErrorHandler,
  mapErrorToResponse,
} from '@cosmneo/onion-lasagna/backend/frameworks/fastify';
```

---

## Quick Start

```typescript



const app = Fastify();

// Apply error handler
app.setErrorHandler(onionErrorHandler);

// Register routes
registerFastifyRoutes(app, routes);

app.listen({ port: 3000 });
```

---

## Registering Routes

The `registerFastifyRoutes` function registers your controllers with Fastify:

```typescript


const routes: RouteInput[] = [
  {
    metadata: {
      method: 'GET',
      path: '/users/{userId}',
    },
    controller: getUserController,
    requestDtoFactory: GetUserRequestDto.create,
  },
];

registerFastifyRoutes(app, routes);
```

### Path Parameter Conversion

Paths use `{param}` syntax which is automatically converted to Fastify's `:param` format.

---

## Options

```typescript
interface RegisterRoutesOptions {
  prefix?: string;
  middlewares?: FastifyMiddleware[];
}

registerFastifyRoutes(app, routes, {
  prefix: '/api/v1',
  middlewares: [authMiddleware],
});
```

---

## Contextual Routes (Protected Routes)

For routes that need authentication context, use `ContextualRouteInput` with a `contextExtractor`:

```typescript

  ContextualRouteInput,
  ContextualHttpRequest,
} from '@cosmneo/onion-lasagna/backend/frameworks/fastify';

interface AuthContext {
  userId: string;
  roles: string[];
}

const protectedRoutes: ContextualRouteInput[] = [
  {
    metadata: { method: 'GET', path: '/profile' },
    controller: getProfileController,
    requestDtoFactory: (req: ContextualHttpRequest) =>
      GetProfileRequestDto.create(req),
  },
];

registerFastifyRoutes(app, protectedRoutes, {
  middlewares: [authMiddleware],
  contextExtractor: (request): AuthContext => ({
    userId: request.user.id,
    roles: request.user.roles ?? [],
  }),
});
```

### Route Input Types

| Type | Use Case |
|------|----------|
| `HttpRouteInput` | Public routes (no auth context) |
| `ContextualRouteInput` | Protected routes with auth context |
| `RouteInputOrArray` | Single or array of public routes |
| `ContextualRouteInputOrArray` | Single or array of protected routes |

---

## Error Handler

The `onionErrorHandler` maps domain errors to HTTP responses:

```typescript
app.setErrorHandler(onionErrorHandler);
```

### Error Mapping

| Error Type | HTTP Status | Body |
|------------|-------------|------|
| `ObjectValidationError` | 400 | `{ errorCode, message, errorItems }` |
| `InvalidRequestError` | 400 | `{ errorCode, message, errorItems }` |
| `AccessDeniedError` | 403 | `{ errorCode, message }` |
| `NotFoundError` | 404 | `{ errorCode, message }` |
| `ConflictError` | 409 | `{ errorCode, message }` |
| `UnprocessableError` | 422 | `{ errorCode, message }` |
| `DomainError` | 500 | Masked |
| `InfraError` | 500 | Masked |
| Unknown | 500 | Masked |


**Masked errors** return `{ "message": "An unexpected error occurred", "errorCode": "INTERNAL_ERROR" }`. Domain and infrastructure errors are masked to prevent leaking implementation details. See [Error Handling](/docs/patterns/error-handling#translating-domain-errors) for how to expose business errors.


---

## Custom Error Handling

Use `mapErrorToResponse` for custom handling:

```typescript


app.setErrorHandler((error, request, reply) => {
  console.error('Error:', error);

  const { statusCode, body } = mapErrorToResponse(error);
  reply.status(statusCode).send(body);
});
```

---

## Complete Example

```typescript




const app = Fastify({ logger: true });

// Plugins
await app.register(cors);

// Error handling
app.setErrorHandler(onionErrorHandler);

// Health check
app.get('/health', () => ({ status: 'ok' }));

// API routes
registerFastifyRoutes(app, userRoutes, { prefix: '/api/v1' });
registerFastifyRoutes(app, orderRoutes, { prefix: '/api/v1' });

// Start
try {
  await app.listen({ port: 3000 });
  console.log('Server running at http://localhost:3000');
} catch (err) {
  app.log.error(err);
  process.exit(1);
}
```

---

## Type Providers

Fastify's type system works with the integration:

```typescript



const app = Fastify().withTypeProvider();
```
---

# NestJS Integration
> Use onion-lasagna patterns with NestJS framework.

## Installation

```bash
bun add @nestjs/core @nestjs/common @nestjs/platform-express
```

Import the NestJS integration:

```typescript

  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
  BaseNestController,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';
```

---

## Quick Start

```typescript


  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)
@UseInterceptors(OnionLasagnaResponseInterceptor)

  constructor(private readonly getUserQuery: GetUserQueryInboundPort) {}

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = GetUserRequestDto.create(request);
    return this.getUserQuery.execute(dto);
  }
}
```

---

## @OnionLasagnaRequest Decorator

Extracts an `HttpRequest` object from the NestJS request:

```typescript



@Get(':id')
async getItem(@OnionLasagnaRequest() request: HttpRequest) {
  // request contains: pathParams, queryParams, body, headers
}
```

The `HttpRequest` structure:

```typescript
interface HttpRequest {
  pathParams: Record;
  queryParams: Record;
  body: unknown;
  headers: Record;
}
```

### With Context Extractor (Protected Routes)

For routes that need authentication context, pass a `contextExtractor` function to the decorator:

```typescript


  OnionLasagnaRequest,
  type NestContextExtractor,
  type ContextualHttpRequest,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';

interface AuthContext {
  user: { id: string; email: string };
  requestId: string;
}

const extractAuthContext: NestContextExtractor = (ctx) => {
  const request = ctx.switchToHttp().getRequest();
  return {
    user: request.user,        // Set by AuthGuard
    requestId: request.id,
  };
};

@Controller('users')

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(
    @OnionLasagnaRequest(extractAuthContext) request: ContextualHttpRequest
  ) {
    // request.context.user is type-safe
    const dto = GetProfileRequestDto.create(request);
    return this.getProfileQuery.execute(dto);
  }
}
```

The `ContextualHttpRequest` extends `HttpRequest` with a `context` property containing your auth data.

---

## OnionLasagnaExceptionFilter

Maps domain errors to HTTP responses:

```typescript



// Apply to controller
@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)


// Or apply globally in main.ts
app.useGlobalFilters(new OnionLasagnaExceptionFilter());
```

### Error Mapping

| Error Type | HTTP Status |
|------------|-------------|
| `ObjectValidationError` | 400 |
| `InvalidRequestError` | 400 |
| `AccessDeniedError` | 403 |
| `NotFoundError` | 404 |
| `ConflictError` | 409 |
| `UnprocessableError` | 422 |
| Internal errors | 500 |

---

## OnionLasagnaResponseInterceptor

Extracts `HttpResponse` data from controller returns:

```typescript



@Controller('users')
@UseInterceptors(OnionLasagnaResponseInterceptor)


// Or apply globally
app.useGlobalInterceptors(new OnionLasagnaResponseInterceptor());
```

This allows controllers to return `HttpResponse` objects and have them automatically unwrapped.

---

## BaseNestController

A base class for NestJS controllers using onion patterns:

```typescript


@Controller('users')

  constructor(
    private readonly getUserQuery: GetUserQueryInboundPort,
    private readonly createUserCommand: CreateUserCommandInboundPort,
  ) {
    super();
  }

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    return this.execute(request, GetUserRequestDto, this.getUserQuery);
  }

  @Post()
  async createUser(@OnionLasagnaRequest() request: HttpRequest) {
    return this.execute(request, CreateUserRequestDto, this.createUserCommand);
  }
}
```

---

## Module Setup

```typescript





@Module({
  controllers: [UsersController],
  providers: [
    {
      provide: 'GetUserQueryInboundPort',
      useClass: GetUserQuery,
    },
    {
      provide: 'UserRepository',
      useClass: UserRepository,
    },
  ],
})

```

---

## Global Setup

Configure filters and interceptors globally in `main.ts`:

```typescript


  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global exception filter
  app.useGlobalFilters(new OnionLasagnaExceptionFilter());

  // Global response interceptor
  app.useGlobalInterceptors(new OnionLasagnaResponseInterceptor());

  await app.listen(3000);
}

bootstrap();
```

---

## Complete Example

```typescript
// users.controller.ts


  OnionLasagnaRequest,
  OnionLasagnaExceptionFilter,
  OnionLasagnaResponseInterceptor,
} from '@cosmneo/onion-lasagna/backend/frameworks/nestjs';


@Controller('users')
@UseFilters(OnionLasagnaExceptionFilter)
@UseInterceptors(OnionLasagnaResponseInterceptor)

  constructor(
    private readonly getUserQuery: GetUserQueryInboundPort,
    private readonly createUserCommand: CreateUserCommandInboundPort,
  ) {}

  @Get(':userId')
  async getUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = GetUserRequestDto.create(request);
    const result = await this.getUserQuery.execute(dto);
    return HttpResponse.ok(result.data);
  }

  @Post()
  async createUser(@OnionLasagnaRequest() request: HttpRequest) {
    const dto = CreateUserRequestDto.create(request);
    const result = await this.createUserCommand.execute(dto);
    return HttpResponse.created(result.data);
  }
}
```
---

# New Endpoint
> Step-by-step guide to creating a new HTTP endpoint

## Decision: Direct BC vs Orchestration

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Steps

### 1. Create Request/Response DTOs

```typescript:presentation/http/users/get-user/request.dto.ts
const getUserRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});
type GetUserRequest = z.infer;

// presentation/http/users/get-user/response.dto.ts
const getUserResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});
type GetUserResponse = z.infer;
```

### 2. Create Endpoint Metadata

```typescript:presentation/http/users/get-user/endpoint.metadata.ts



  id: 'get-user',
  shortId: 'gu',
  name: 'getUser',
  description: 'Gets a user by their ID.',
  method: 'GET',
  path: '/{userId}',  // Use {param} syntax - converted to :param by framework
  openApi: {
    summary: 'Get user by ID',
  },
};
```


Paths use `{param}` syntax which is framework-agnostic. Framework integrations convert to the appropriate format (e.g., `:param` for Hono/Express).


**OpenAPI successStatus defaults:**

| Method | Default Status | When to Override |
|--------|----------------|------------------|
| GET | 200 | Rarely needed |
| POST | 201 | Use 200 for non-creation operations |
| PUT | 200 | Use 204 for no-content responses |
| PATCH | 200 | Use 204 for no-content responses |
| DELETE | 204 | Use 200 if returning deleted resource |

```typescript:endpoint.metadata.ts
// POST that creates - use default 201
openApi: { summary: 'Create user' }

// POST that doesn't create - override to 200
openApi: { summary: 'Login', successStatus: 200 }

// DELETE with no response body - use default 204
openApi: { summary: 'Delete user' }
```

### 3. Define Inbound Port (in BC)

```typescript:app/ports/inbound/get-user.query.inbound.ts
interface GetUserQueryInboundPort {
  execute(input: GetUserInput): Promise;
}
```

### 4. Implement Use Case

```typescript:app/use-cases/queries/get-user.use-case.ts


class GetUserQuery
  extends BaseInboundAdapter
  implements GetUserQueryInboundPort
{
  constructor(private readonly userRepo: UserReadRepositoryOutboundPort) {
    super();
  }

  protected async handle(input: GetUserInputDto): Promise {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    return GetUserOutputDto.create({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Extend `BaseInboundAdapter` and implement `handle()` for automatic error wrapping. The inherited `execute()` method handles error boundaries.

### 5. Create Mappers

```typescript:presentation/http/users/get-user/to-use-case.mapper.ts
function toGetUserInput(request: GetUserRequest): GetUserInput {
  return { userId: request.pathParams.userId };
}

// presentation/http/users/get-user/to-response.mapper.ts
function toGetUserResponse(output: GetUserOutput): GetUserResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

### 6. Create Access Guard (if needed)

Access guards are **functions**, not classes:

```typescript:presentation/http/users/get-user/access-guard.ts


// Simple guard - allow any authenticated user
const getUserAccessGuard: AccessGuard = (request) => ({
  isAllowed: true,
});

// Guard with authorization check
const getUserAccessGuardWithAuth: AccessGuard = async (request) => {
  const isOwner = request.data.pathParams.userId === request.data.currentUserId;
  return {
    isAllowed: isOwner,
    reason: isOwner ? undefined : 'You can only view your own profile',
  };
};
```

### 7. Wire in Bootstrap

```typescript:bootstrap/user.bootstrap.ts
const userReadRepo = new UserRepository(new UserPersistence());
const getUserQuery = new GetUserQuery(userReadRepo);
```

### 8. Create Controller

Use `BaseController` or `GuardedController` to wire the pipeline:

```typescript:presentation/http/users/get-user/controller.ts


// Without access guard
const getUserController = BaseController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
});

// With access guard
const getUserControllerGuarded = GuardedController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
  accessGuard: getUserAccessGuard,
});
```

---

## Void Operations (DELETE, UPDATE)

For operations that return no content (HTTP 204):

### Port with void output

```typescript:app/ports/inbound/delete-user.command.port.ts


interface DeleteUserPort extends BaseInboundPort {}
```

### Use Case returning void

Since `BaseInboundAdapter` requires a DTO output, create a void adapter in your codebase:


`BaseVoidInboundAdapter` is **not** a library export—it's a pattern you implement. Create this class once in your project and reuse it for all void-returning use cases.


```typescript:app/use-cases/base-void-inbound-adapter.ts




  implements BaseInboundPort
{
  protected abstract handle(input: TInDto): Promise;

  public async execute(input: TInDto): Promise {
    return wrapErrorUnlessAsync(
      () => this.handle(input),
      (cause) => new UseCaseError({ message: 'Unexpected use case error', cause }),
      [ObjectValidationError, UseCaseError, DomainError, InfraError],
    );
  }
}
```

```typescript:app/use-cases/commands/delete-user.command.ts
class DeleteUserUseCase extends BaseVoidInboundAdapter implements DeleteUserPort {
  constructor(private readonly userRepo: UserRepositoryPort) {
    super();
  }

  protected async handle(input: DeleteUserInputDto): Promise {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    await this.userRepo.delete(user.id);
  }
}
```

### Response mapper for 204

```typescript:presentation/http/users/delete-user/mappers.ts



  validator: DtoValidator,
): DeleteUserResponseDto {
  return new DeleteUserResponseDto(
    { statusCode: 204, body: null },
    validator,
  );
}
```

### Controller for void operations

```typescript:bootstrap/controller.bootstrap.ts
deleteUserController: BaseController.create({
  requestMapper: (req: DeleteUserRequestDto) =>
    deleteUserToInputMapper(req, SKIP_DTO_VALIDATION),
  useCase: deleteUserUseCase,
  // Response mapper ignores output (void) and returns 204
  responseMapper: () => deleteUserToResponseMapper(SKIP_DTO_VALIDATION),
}),
```


For void operations, the `responseMapper` receives `void` and returns a 204 response with `body: null`.


---

## Checklist

- [ ] Request/Response DTOs created
- [ ] Endpoint metadata created
- [ ] Inbound port defined
- [ ] Use case implemented
- [ ] Mappers created
- [ ] Access guard created (if needed)
- [ ] Bootstrap wired
- [ ] Controller created (or generated)
---

# New Bounded Context
> Step-by-step guide to creating a new Bounded Context

## Structure

```
bounded-contexts/{bc-name}/
├── app/
│   ├── ports/
│   │   ├── inbound/
│   │   └── outbound/
│   └── use-cases/
│       ├── queries/
│       └── commands/
├── domain/
│   ├── aggregates/
│   ├── entities/
│   ├── value-objects/
│   └── exceptions/
└── infra/
```

---

## Steps

### 1. Create Folder Structure

Create all directories under `bounded-contexts/{bc-name}/`.

### 2. Define Domain Model

Start with aggregates and value objects:

```typescript:domain/value-objects/user-id.vo.ts
class UserId {
  private constructor(private readonly _value: string) {}
  static create(value: string): UserId { ... }
  static generate(): UserId { ... }
  get value(): string { return this._value; }
}

// domain/aggregates/user.aggregate.ts
class UserAggregate {
  static create(data: CreateUserData): UserAggregate { ... }
  static reconstitute(data: UserData): UserAggregate { ... }
}
```

### 3. Define Exceptions

```typescript:domain/exceptions/user-not-found.error.ts
class UserNotFoundError extends Error {
  constructor(userId: string) {
    super(`User not found: ${userId}`);
  }
}
```

### 4. Define Outbound Ports

```typescript:app/ports/outbound/user.repository.outbound.ts
interface UserReadRepositoryOutboundPort {
  findById(id: UserId): Promise;
}

interface UserWriteRepositoryOutboundPort {
  save(user: UserAggregate): Promise;
}
```

### 5. Define Inbound Ports

```typescript:app/ports/inbound/create-user.command.inbound.ts
interface CreateUserCommandInboundPort {
  execute(input: CreateUserInput): Promise;
}
```

### 6. Implement Use Cases

```typescript:app/use-cases/commands/create-user.command.ts
class CreateUserCommand implements CreateUserCommandInboundPort {
  constructor(
    private readonly readRepo: UserReadRepositoryOutboundPort,
    private readonly writeRepo: UserWriteRepositoryOutboundPort,
  ) {}

  async execute(input: CreateUserInput): Promise {
    const user = UserAggregate.create(input);
    await this.writeRepo.save(user);
    return { id: user.id.value };
  }
}
```

### 7. Implement Infrastructure (if BC-scoped)

```typescript:infra/implementations/user/user.repository.ts
class UserRepository implements 
  UserReadRepositoryOutboundPort, 
  UserWriteRepositoryOutboundPort 
{
  constructor(private readonly persistence: UserPersistence) {}
  // ...
}
```

---

## Checklist

- [ ] Folder structure created
- [ ] Value objects defined
- [ ] Aggregates defined
- [ ] Domain exceptions created
- [ ] Outbound ports defined
- [ ] Inbound ports defined
- [ ] Use cases implemented
- [ ] Infrastructure implemented (if BC-scoped)
---

# CLI Overview
> Planned tooling to automate common tasks

## Current State vs Future

| Task | Current | Future |
|------|---------|--------|
| Controller wiring | Manual in bootstrap | CLI generated |
| HTTP client | Manual | CLI generated |
| New endpoint | 6+ files created manually | CLI scaffolded |
| Dependency rules | Developer discipline | Linter enforced |

---

## Planned Tools

| Tool | Purpose |
|------|---------|
| **Controller Generator** | Auto-wire validate → guard → map → execute → respond |
| **HTTP Client Generator** | TypeScript-safe clients from request/response schemas |
| **Endpoint Scaffold** | Generate all files for a new endpoint |
| **Linter Rules** | Enforce one-way module deps, layer import rules |

---

## See Also

These features are planned for future releases:

- Controller Wiring
- HTTP Client Generation
- Endpoint Scaffolding
- Linter Rules
---

# Endpoint Scaffolding
> CLI command to generate all files for a new endpoint

## Command

```bash
onion-cli generate endpoint users/get-user --method GET --path /users/:userId
```

---

## Generated Files

```
presentation/http/users/get-user/
├── endpoint.metadata.ts
├── request.dto.ts
├── response.dto.ts
├── access-guard.ts
├── to-use-case.mapper.ts
└── to-response.mapper.ts
```

Plus stubs in the BC:

```
app/ports/inbound/get-user.query.inbound.ts
app/use-cases/queries/get-user.query.ts
```

---

## Options

| Flag | Description |
|------|-------------|
| `--method` | HTTP method (GET, POST, etc.) |
| `--path` | URL path with params |
| `--bc` | Target bounded context |
| `--orchestration` | Create as composition/workflow instead |
---

# Controller Wiring
> Auto-generate controllers that wire all endpoint components

## Current Manual Approach

```typescript:bootstrap/user.bootstrap.ts
const userPersistence = new UserPersistence(db);
const userRepo = new UserRepository(userPersistence);
const getUserQuery = new GetUserQuery(userRepo);
const getUserAccessGuard = new GetUserAccessGuard();

// Controller manually wires everything
class GetUserController {
  static async execute(event: APIGatewayEvent) {
    const request = parseRequest(event);

    // 1. Validate
    const validated = getUserRequestSchema.parse(request);

    // 2. Check access
    const guardResult = await getUserAccessGuard.guard(validated);
    if (!guardResult.allowed) throw new ForbiddenError();

    // 3. Map to input
    const input = toGetUserInput(validated);

    // 4. Execute
    const output = await getUserQuery.execute(input);

    // 5. Map to response
    return toGetUserResponse(output);
  }
}
```

---

## Future Generated Approach

```bash
onion-cli generate controller get-user
```

Generates a controller that:
- Reads endpoint metadata
- Wires validation, guard, mappers, use case
- Handles exception mapping
- Outputs framework-specific handler
---

# HTTP Client Generation
> Generate TypeScript-safe HTTP clients from schemas

## Goal

Frontend developers get auto-completed, type-safe API calls.

---

## Source of Truth

- `presentation/http/{resource}/{endpoint}/request.dto.ts`
- `presentation/http/{resource}/{endpoint}/response.dto.ts`

---

## Generated Output

```typescript:packages/shared/clients/http/user.client.ts

class UserClient {
  constructor(
    private readonly baseUrl: string,
    private readonly auth: AuthConfig,
  ) {}

  async getUser(userId: string): Promise {
    const response = await fetch(`${this.baseUrl}/users/${userId}`, {
      headers: this.auth.headers(),
    });
    return getUserResponseSchema.parse(await response.json());
  }

  async createUser(data: CreateUserRequest['body']): Promise {
    // ...
  }
}
```

---

## Usage

```typescript
const userClient = new UserClient('https://api.example.com', authConfig);
const user = await userClient.getUser('123');  // Fully typed!
```
---

# Linter Rules
> ESLint rules to enforce architecture constraints

## Rules

### One-Way Module Dependencies

Modules can import from each other, but only one direction.

```typescript
// ✅ OK: Module A imports from Module B


// ❌ ERROR: Module B also imports from Module A (creates cycle)

```

### Layer Import Restrictions

| From | Can Import |
|------|------------|
| BC | Shared only |
| Infrastructure | BC ports, domain, shared |
| Orchestrations | BC ports + use cases, shared |
| Presentation | All inner layers |

```typescript
// In bounded-contexts/user/
// ❌ ERROR: Cannot import from infrastructure

```

### No `implements` in Persistence/External

```typescript
// ❌ ERROR: Only implementations/ can use `implements`
class UserPersistence implements UserRepositoryOutboundPort { ... }
```

---

## Configuration

```javascript:eslint.config.js



  onionLasagnaPlugin.configs.recommended,
];
```
---

# Anti-Patterns
> What NOT to do when implementing Onion Lasagna Architecture

## Bounded Context

### ❌ Framework Code in Domain

```typescript
// BAD: Using Express in domain

class CreateUserCommand {
  execute(req: Request, res: Response) { ... }
}
```

### ❌ Environment Variables in Domain

```typescript
// BAD: Reading env vars in BC
const apiKey = process.env.API_KEY;
```

### ❌ Direct Cross-BC Import

```typescript
// BAD: Importing from another BC

```

---

## Infrastructure

### ❌ Business Logic in Repository

```typescript
// BAD: Price calculation in repository
async findWithDiscount(id: string): Promise {
  const product = await this.db.find(id);
  product.price = product.price * 0.9;  // BAD!
  return product;
}
```

### ❌ `implements` in Persistence/External

```typescript
// BAD: Persistence should NOT implement port
class UserPersistence implements UserRepositoryOutboundPort { ... }

// GOOD: Only implementations/ use `implements`
class UserRepository implements UserRepositoryOutboundPort {
  constructor(private persistence: UserPersistence) {}
}
```

---

## Presentation

### ❌ Business Logic in Access Guard

```typescript
// BAD: Custom logic in guard
async guard(request: Request): Promise {
  const discount = request.user.isVIP ? 0.2 : 0;  // BAD!
  return { allowed: true, discount };
}
```

### ❌ Business Logic in Mapper

```typescript
// BAD: Calculation in mapper
function toResponse(order: Order): OrderResponse {
  return {
    ...order,
    total: order.items.reduce((sum, i) => sum + i.price, 0),  // BAD!
  };
}
```

---

## Dependencies

### ❌ Outer Layer Import in Inner Layer

```typescript
// BAD: BC importing from Infrastructure

```

### ❌ Two-Way Module Dependencies

```typescript
// BAD: Module A imports Module B, AND Module B imports Module A
// This creates circular dependency
```

---

## Naming

### ❌ Inconsistent Port Naming

```typescript
// BAD: Missing port suffix
interface UserRepository { ... }

// GOOD
interface UserRepositoryOutboundPort { ... }
```
---
