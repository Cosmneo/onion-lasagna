---
title: "Aggregates"
description: "Entity clusters treated as a single unit. Enforce business invariants and emit domain events."
icon: "boxes-stacked"
---

## BaseEntity and BaseAggregateRoot

The library provides base classes for entities and aggregates:

```typescript
import {
  BaseEntity,
  BaseAggregateRoot,
  BaseDomainEvent,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';
```

---

## BaseEntity

Entities have identity and can be compared by ID:

```typescript
abstract class BaseEntity<
  TId extends BaseValueObject<unknown>,
  TProps extends object,
> {
  private readonly _id: TId;
  private readonly _version: number;
  protected _props: TProps;

  // Public API
  get id(): TId;
  get version(): number;
  equals(other: BaseEntity<TId, TProps>): boolean;

  // Protected (for subclasses)
  protected get props(): TProps;
  protected idEquals(a: TId, b: TId): boolean;
  protected nextVersion(): number;
}
```

---

## BaseAggregateRoot

Aggregates extend `BaseEntity` with domain event support:

```typescript
abstract class BaseAggregateRoot<
  TId extends BaseValueObject<unknown>,
  TProps extends object,
> extends BaseEntity<TId, TProps> {
  // Add a domain event to be published
  protected addDomainEvent(event: BaseDomainEvent): void;

  // Get and clear all domain events (for publishing)
  public pullDomainEvents(): BaseDomainEvent[];

  // Peek at events without clearing
  public peekDomainEvents(): readonly BaseDomainEvent[];

  // Check if there are pending events
  public get hasDomainEvents(): boolean;

  // Clear all events (called after publishing)
  protected clearDomainEvents(): void;
}
```

---

## Creating an Aggregate

```typescript
import {
  BaseAggregateRoot,
  BaseDomainEvent,
  InvariantViolationError,
} from '@cosmneo/onion-lasagna/backend/core/onion-layers';

interface OrderProps {
  customerId: CustomerId;
  items: OrderItem[];
  status: OrderStatus;
  createdAt: Date;
}

class OrderAggregate extends BaseAggregateRoot<OrderId, OrderProps> {
  private constructor(id: OrderId, props: OrderProps, version = 0) {
    super(id, props, version);
  }

  // Factory for NEW instances
  static create(data: CreateOrderData): OrderAggregate {
    const order = new OrderAggregate(
      OrderId.generate(),
      {
        customerId: CustomerId.create(data.customerId),
        items: [],
        status: OrderStatus.DRAFT,
        createdAt: new Date(),
      },
    );

    // Emit creation event
    order.addDomainEvent(new OrderCreatedEvent({
      orderId: order.id.value,
      customerId: data.customerId,
      totalAmount: 0,
    }));

    return order;
  }

  // Factory for EXISTING instances (from DB)
  static reconstitute(data: OrderData, version: number): OrderAggregate {
    return new OrderAggregate(
      OrderId.create(data.id),
      {
        customerId: CustomerId.create(data.customerId),
        items: data.items.map(OrderItem.reconstitute),
        status: data.status,
        createdAt: data.createdAt,
      },
      version,
    );
  }

  // Domain methods (enforce invariants)
  addItem(item: AddItemData): void {
    if (this._props.status !== OrderStatus.DRAFT) {
      throw new InvariantViolationError({
        message: 'Cannot add items to non-draft order',
        code: 'ORDER_NOT_EDITABLE',
      });
    }
    if (this._props.items.length >= 50) {
      throw new InvariantViolationError({
        message: 'Maximum 50 items per order',
        code: 'ORDER_LIMIT_EXCEEDED',
      });
    }

    this._props.items.push(OrderItem.create(item));
    this.addDomainEvent(new OrderItemAddedEvent({
      orderId: this.id.value,
      productId: item.productId,
      quantity: item.quantity,
    }));
  }

  submit(): void {
    if (this._props.items.length === 0) {
      throw new InvariantViolationError({
        message: 'Cannot submit empty order',
        code: 'EMPTY_ORDER',
      });
    }

    this._props.status = OrderStatus.PENDING;
    this.addDomainEvent(new OrderSubmittedEvent({
      orderId: this.id.value,
      submittedAt: new Date(),
    }));
  }

  // Getters
  get customerId(): CustomerId { return this._props.customerId; }
  get status(): OrderStatus { return this._props.status; }
  get items(): readonly OrderItem[] { return [...this._props.items]; }
}
```

---

## Domain Events

Create domain events by extending `BaseDomainEvent`. Use a **payload object** for type-safe construction:

```typescript
import { BaseDomainEvent } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

interface OrderCreatedPayload {
  orderId: string;
  customerId: string;
  totalAmount: number;
}

class OrderCreatedEvent extends BaseDomainEvent<OrderCreatedPayload> {
  constructor(payload: OrderCreatedPayload) {
    super('OrderCreated', payload.orderId, payload);
  }
}

interface OrderSubmittedPayload {
  orderId: string;
  submittedAt: Date;
}

class OrderSubmittedEvent extends BaseDomainEvent<OrderSubmittedPayload> {
  constructor(payload: OrderSubmittedPayload) {
    super('OrderSubmitted', payload.orderId, payload);
  }
}
```

<Callout type="info">
The payload object pattern ensures all event data is self-contained. The `aggregateId` is extracted from the payload rather than passed separately.
</Callout>

`BaseDomainEvent` provides:
- `eventId` - Unique ID for the event
- `eventName` - Name of the event
- `aggregateId` - ID of the aggregate that emitted it
- `occurredOn` - Timestamp when the event occurred
- `payload` - Event-specific data
- `toJSON()` - Serialize for storage/transport

---

## Publishing Domain Events

Use `pullDomainEvents()` to get and clear events after persisting:

```typescript
class CreateOrderCommand {
  constructor(
    private readonly orderRepo: OrderWriteRepositoryOutboundPort,
    private readonly eventPublisher: EventPublisherOutboundPort,
  ) {}

  async execute(input: CreateOrderInput): Promise<void> {
    const order = OrderAggregate.create(input);

    // Persist first
    await this.orderRepo.save(order);

    // Then publish events (get and clear)
    const events = order.pullDomainEvents();
    await this.eventPublisher.publishAll(events);
  }
}
```

---

## Optimistic Locking

Use `version` for optimistic concurrency. Increment the version when persisting:

```typescript
class OrderRepository {
  async save(order: OrderAggregate): Promise<void> {
    const affectedRows = await this.db.query(
      `UPDATE orders SET ..., version = ? WHERE id = ? AND version = ?`,
      [order.version + 1, order.id.value, order.version],
    );

    if (affectedRows === 0) {
      throw new ConcurrencyError('Order was modified by another process');
    }
  }
}
```

<Callout type="info">
The `version` property is public for reading. The `nextVersion()` method is protected - use `version + 1` in repositories to increment the version when saving.
</Callout>

---

## Protected Utility Methods

`BaseEntity` provides utility methods for subclasses:

### idEquals

Compares two IDs of the same type using the Value Object's `equals` method:

```typescript
class OrderAggregate extends BaseAggregateRoot<OrderId, OrderProps> {
  // Use idEquals for comparing aggregate IDs (same TId type)
  isSameOrder(otherId: OrderId): boolean {
    return this.idEquals(this.id, otherId);
  }

  // For child entity IDs, use equals() directly
  hasItem(itemId: OrderItemId): boolean {
    return this._props.items.some((item) => item.id.equals(itemId));
  }
}
```

### Version Increment

When saving to the database, increment the version:

```typescript
// In repository
async save(order: OrderAggregate): Promise<void> {
  await this.db.update({
    ...this.toRow(order),
    version: order.version + 1,
  }).where({ id: order.id.value, version: order.version });
}
```

<Callout type="info">
The `version` property is public for reading. Use `version + 1` in your repository when persisting changes to implement optimistic locking.
</Callout>

---

## Rules

- ✅ Extend `BaseAggregateRoot` for event-sourced aggregates
- ✅ Use factory methods (`create`, `reconstitute`)
- ✅ Enforce all invariants in domain methods
- ✅ Use `InvariantViolationError` for business rule violations
- ✅ Emit domain events for state changes
- ✅ Return copies of collections from getters
- ✅ Reference other aggregates by ID only
- ✅ Use `version` for optimistic locking
- ❌ Never create with `new` directly
- ❌ Never reference other aggregates directly
- ❌ Never publish events before persisting

---

## Hydration

Repositories are responsible for hydrating aggregates:

```typescript
class OrderRepository extends BaseOutboundAdapter {
  async findById(id: OrderId): Promise<OrderAggregate | null> {
    const row = await this.persistence.findById(id.value);
    if (!row) return null;
    return OrderAggregate.reconstitute(row, row.version);
  }
}
```
