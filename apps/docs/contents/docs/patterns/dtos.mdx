---
title: "DTOs"
description: "Data Transfer Objects for carrying data between layers. Immutable, validated at creation."
icon: "box"
---

## Types

| DTO | Purpose | Location |
|-----|---------|----------|
| **Request DTO** | HTTP request shape | `presentation/http/{endpoint}/request.dto.ts` |
| **Response DTO** | HTTP response shape | `presentation/http/{endpoint}/response.dto.ts` |
| **Input DTO** | Use case input | `app/ports/inbound/{use-case}/` |
| **Output DTO** | Use case output | `app/ports/inbound/{use-case}/` |

---

## BaseDto Class

All DTOs extend `BaseDto<T>` which provides:
- Immutable data access via `.data` getter
- Automatic validation at construction
- Support for skipping validation when reconstituting from trusted sources

```typescript
import { BaseDto, SKIP_DTO_VALIDATION } from '@cosmneo/onion-lasagna/backend/core/global';
import { createZodValidator } from '@cosmneo/onion-lasagna/backend/core/validators/zod';
import { z } from 'zod';

// Define your schema
const createUserRequestSchema = z.object({
  body: z.object({
    email: z.string().email(),
    name: z.string().min(1).max(100),
    password: z.string().min(8),
  }),
});

type CreateUserRequestData = z.infer<typeof createUserRequestSchema>;

// Create a DTO class extending BaseDto
class CreateUserRequestDto extends BaseDto<CreateUserRequestData> {
  private constructor(data: CreateUserRequestData) {
    super(data, createZodValidator(createUserRequestSchema));
  }

  static create(data: unknown): CreateUserRequestDto {
    // Validates and throws ObjectValidationError if invalid
    return new CreateUserRequestDto(data as CreateUserRequestData);
  }

  // Convenience getters
  get email(): string {
    return this.data.body.email;
  }

  get name(): string {
    return this.data.body.name;
  }
}
```

---

## Use Case DTOs

Input and output DTOs follow the same pattern:

```typescript
const createUserInputSchema = z.object({
  email: z.string().email(),
  name: z.string(),
  hashedPassword: z.string(),
});

type CreateUserInputData = z.infer<typeof createUserInputSchema>;

class CreateUserInputDto extends BaseDto<CreateUserInputData> {
  private constructor(data: CreateUserInputData) {
    super(data, createZodValidator(createUserInputSchema));
  }

  static create(data: unknown): CreateUserInputDto {
    return new CreateUserInputDto(data as CreateUserInputData);
  }
}
```

---

## Skipping Validation

Use `SKIP_DTO_VALIDATION` when reconstituting from trusted sources (e.g., database, internal mapping):

```typescript
class UserOutputDto extends BaseDto<UserOutputData> {
  private constructor(data: UserOutputData, skipValidation = false) {
    super(data, skipValidation ? SKIP_DTO_VALIDATION : createZodValidator(schema));
  }

  static create(data: unknown): UserOutputDto {
    return new UserOutputDto(data as UserOutputData);
  }

  // For internal use when data is already validated
  static fromTrusted(data: UserOutputData): UserOutputDto {
    return new UserOutputDto(data, true);
  }
}
```

---

## Other Validators

The library supports multiple validators. Replace the Zod validator with your preferred choice:

```typescript
// ArkType
import { createArkTypeValidator } from '@cosmneo/onion-lasagna/backend/core/validators/arktype';
import { type } from 'arktype';

const schema = type({ email: 'string.email', name: 'string' });
super(data, createArkTypeValidator(schema));

// Valibot
import { createValibotValidator } from '@cosmneo/onion-lasagna/backend/core/validators/valibot';
import * as v from 'valibot';

const schema = v.object({ email: v.pipe(v.string(), v.email()), name: v.string() });
super(data, createValibotValidator(schema));

// TypeBox
import { createTypeBoxValidator } from '@cosmneo/onion-lasagna/backend/core/validators/typebox';
import { Type } from '@sinclair/typebox';

const schema = Type.Object({ email: Type.String({ format: 'email' }), name: Type.String() });
super(data, createTypeBoxValidator(schema));
```

---

## Validation Errors

When validation fails, an `ObjectValidationError` is thrown with structured field-level errors:

```typescript
try {
  const dto = CreateUserRequestDto.create(invalidData);
} catch (error) {
  if (error instanceof ObjectValidationError) {
    // error.validationErrors is an array of { field: string; message: string }
    console.log(error.validationErrors);
    // [{ field: 'body.email', message: 'Invalid email format' }]
  }
}
```

Controllers automatically convert `ObjectValidationError` to `InvalidRequestError` with a 400 status code.

---

## Centralized Validators (Recommended)

For larger projects, create validators in a central bootstrap file and inject them:

```typescript:bootstrap/validators.bootstrap.ts
import { createZodValidator } from '@cosmneo/onion-lasagna/backend/core/validators/zod';
import { createProjectRequestSchema, createProjectResponseSchema } from '../presentation/http/...';

// Create validators once, reuse everywhere
export const createProjectRequestValidator = createZodValidator(createProjectRequestSchema);
export const createProjectResponseValidator = createZodValidator(createProjectResponseSchema);
```

Then inject into mappers:

```typescript:presentation/http/projects/create-project/mappers.ts
import type { DtoValidator } from '@cosmneo/onion-lasagna/backend/core/global';
import { SKIP_DTO_VALIDATION } from '@cosmneo/onion-lasagna/backend/core/global';

// Request mapper - validator injected at runtime
export function createProjectToInputMapper(
  request: CreateProjectRequestDto,
  validator: DtoValidator<CreateProjectInput>,
): CreateProjectInputDto {
  return new CreateProjectInputDto(
    {
      name: request.data.body.name,
      description: request.data.body.description,
    },
    validator,  // Validator injected here
  );
}

// Response mapper with validator
export function createProjectToResponseMapper(
  output: CreateProjectOutputDto,
  validator: DtoValidator<CreateProjectResponseData>,
): CreateProjectResponseDto {
  return new CreateProjectResponseDto(
    { statusCode: 201, body: { projectId: output.data.projectId } },
    validator,
  );
}
```

Wire in controllers:

```typescript:bootstrap/controller.bootstrap.ts
import { SKIP_DTO_VALIDATION } from '@cosmneo/onion-lasagna/backend/core/global';
import { createProjectRequestValidator, createProjectResponseValidator } from './validators.bootstrap';

const createProjectController = BaseController.create({
  // Input already validated at HTTP layer, skip re-validation
  requestMapper: (req: CreateProjectRequestDto) =>
    createProjectToInputMapper(req, SKIP_DTO_VALIDATION),
  useCase: createProjectUseCase,
  // Response needs validation before sending to client
  responseMapper: (out: CreateProjectOutputDto) =>
    createProjectToResponseMapper(out, createProjectResponseValidator),
});
```

<Callout type="info">
**When to skip validation:**
- Request → Input mapping: Request DTO already validated at HTTP boundary
- Internal mappings: Data comes from trusted sources (database, other validated DTOs)

**When to validate:**
- Response → HTTP: Ensure response matches expected schema before sending
- External data: Data from third-party APIs or user input
</Callout>

---

## DTO vs Value Object

| Aspect | DTO | Value Object |
|--------|-----|--------------|
| **Purpose** | Transfer data | Represent domain concept |
| **Location** | Presentation / App layer | Domain layer |
| **Behavior** | Minimal (data access) | May have methods |
| **Identity** | None | Compared by value |
| **Base Class** | `BaseDto<T>` | `BaseValueObject<T>` |
