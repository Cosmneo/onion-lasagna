---
title: "Bounded Contexts"
description: "Pure domain logic with ports and use cases"
icon: "cube"
---


Pure domain logic, completely framework-free.

---

## Structure

```
bounded-contexts/{bc-name}/
├── app/
│   ├── ports/
│   │   ├── inbound/
│   │   │   ├── queries/       ← Query port interfaces
│   │   │   └── commands/      ← Command port interfaces
│   │   └── outbound/          ← Repository interfaces
│   └── use-cases/
│       ├── queries/           ← Query implementations
│       └── commands/          ← Command implementations
├── domain/
│   ├── aggregates/
│   │   └── {aggregate}/
│   │       └── policies/
│   ├── entities/
│   ├── value-objects/
│   ├── events/                ← Domain events
│   ├── services/              ← Domain services
│   └── exceptions/
├── infra/
│   ├── outbound-adapters/     ← Port implementations
│   ├── persistence/
│   ├── external-systems/
│   ├── schemas/
│   └── config/
└── presentation/              ← BC-specific HTTP layer
    ├── bootstrap/
    │   ├── controller.bootstrap.ts
    │   └── dto.bootstrap.ts
    └── http/
        └── {resource}/{endpoint}/
```

---

## Golden Rules

1. **NO framework imports**
2. **NO environment variables**
3. **NO direct cross-BC imports**
4. **CAN import** from domain (VOs, aggregates) into infra

---

## Inbound Ports

Interfaces for use cases. Implemented by queries and commands.

```typescript:ports/inbound/queries/find-user-by-id.port.ts
interface FindUserByIdQueryInboundPort {
  execute(input: FindUserByIdInputDto): Promise<FindUserByIdOutputDto>;
}
```

### Naming

| Type | Interface | File |
|------|-----------|------|
| Query | `{Name}QueryInboundPort` | `queries/{name}.port.ts` |
| Command | `{Name}CommandInboundPort` | `commands/{name}.port.ts` |

---

## Outbound Ports

Interfaces for external dependencies. Implemented by infrastructure.

```typescript:ports/outbound/user.repository.outbound.ts
interface UserRepositoryOutboundPort {
  findById(id: UserId): Promise<User | null>;
  save(user: User): Promise<void>;
}
```

---

## Use Cases

Implement inbound ports using `BaseInboundAdapter` for automatic error handling.

```typescript:use-cases/queries/find-user-by-id.use-case.ts
import { BaseInboundAdapter, NotFoundError } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

class FindUserByIdQuery
  extends BaseInboundAdapter<FindUserByIdInputDto, FindUserByIdOutputDto>
  implements FindUserByIdQueryInboundPort
{
  constructor(private readonly userRepo: UserRepositoryOutboundPort) {
    super();
  }

  protected async handle(input: FindUserByIdInputDto): Promise<FindUserByIdOutputDto> {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    return FindUserByIdOutputDto.create({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Implement `handle()` (protected) instead of `execute()`. The `BaseInboundAdapter` provides `execute()` with automatic error wrapping.

---

## Domain

### Aggregates

```typescript
class UserAggregate {
  private constructor(
    private readonly _id: UserId,
    private _email: string,
    private _name: string,
  ) {}

  static create(data: CreateUserData): UserAggregate { ... }
  static reconstitute(data: UserData): UserAggregate { ... }
}
```

### Value Objects

```typescript
class UserId {
  private constructor(private readonly _value: string) {}
  static create(value: string): UserId { ... }
  static generate(): UserId { ... }
  get value(): string { return this._value; }
}
```

See [Aggregates](../patterns/aggregates.md) and [Value Objects](../patterns/value-objects.md) for details.
