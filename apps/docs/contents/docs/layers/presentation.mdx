---
title: "Presentation"
description: "HTTP handlers, controllers, access guards, and mappers"
icon: "globe"
---


HTTP layer: handlers, controllers, access guards, mappers.

---

## Structure

```
presentation/
└── http/
    ├── service.metadata.ts          ← Service-level config (basePath)
    ├── resources/
    │   └── {resource}.metadata.ts   ← Resource metadata
    ├── endpoints/
    │   └── {resource}/
    │       └── {action}.metadata.ts ← Endpoint metadata
    └── {resource}/{endpoint}/
        ├── dtos.ts                  ← Request & Response DTOs
        ├── schemas.ts               ← Zod/validation schemas
        ├── mappers.ts               ← DTO transformations
        └── endpoint.metadata.ts     ← (alternative location)
```

<Callout type="info">
You can organize files as `dtos.ts` + `mappers.ts` (combined) or `request.dto.ts` + `response.dto.ts` + `to-use-case.mapper.ts` + `to-response.mapper.ts` (separate). Choose one pattern and use it consistently.
</Callout>

---

## Route Composition

Routes are built by composing three metadata levels:

### 1. Service Metadata

Defines the base path for the entire bounded context:

```typescript:service.metadata.ts
import type { ServiceMetadata } from '@cosmneo/onion-lasagna/backend/core/presentation';

export const projectManagementServiceMetadata: ServiceMetadata = {
  id: 'project-management-service',
  shortId: 'pms',
  name: 'Project Management',
  description: 'Manages projects, tasks, and statuses',
  basePath: '/api/projects',
  openApi: {
    title: 'Project Management API',
    description: 'API for managing projects',
  },
};
```

### 2. Resource Metadata

Defines a resource within the service:

```typescript:resources/projects.metadata.ts
import type { ResourceMetadata } from '@cosmneo/onion-lasagna/backend/core/presentation';

export const projectsResourceMetadata: ResourceMetadata = {
  id: 'projects',
  shortId: 'prj',
  name: 'Projects',
  description: 'Project management endpoints',
  path: '',  // Empty = at service root
  order: 1,
  openApi: {
    tag: 'Projects',
    tagDescription: 'Project operations',
  },
};
```

### 3. Endpoint Metadata

Defines a specific endpoint:

```typescript:endpoints/projects/create-project.metadata.ts
import type { HttpEndpointMetadata } from '@cosmneo/onion-lasagna/backend/core/presentation';

export const createProjectEndpointMetadata: HttpEndpointMetadata = {
  id: 'create-project',
  shortId: 'cp',
  name: 'createProject',
  description: 'Creates a new project',
  method: 'POST',
  path: '',  // Empty = at resource root
  openApi: {
    summary: 'Create a new project',
    successStatus: 201,
  },
};
```

### computeRoutePath

Combines metadata into a full path:

```typescript
import { computeRoutePath } from '@cosmneo/onion-lasagna/backend/core/presentation';

// Result: '/api/projects'
const path = computeRoutePath(
  projectManagementServiceMetadata,  // basePath: '/api/projects'
  projectsResourceMetadata,          // path: ''
  createProjectEndpointMetadata      // path: ''
);

// For nested resources with path params
// Result: '/api/projects/{projectId}/tasks'
const tasksPath = computeRoutePath(
  projectManagementServiceMetadata,  // basePath: '/api/projects'
  tasksResourceMetadata,             // path: '/{projectId}/tasks'
  listTasksEndpointMetadata          // path: ''
);
```

<Callout type="info">
Paths use `{param}` syntax which is framework-agnostic. Framework integrations convert to the appropriate format (e.g., `:param` for Hono/Express).
</Callout>

---

## Request/Response DTOs

These are the **source of truth** for API contracts.

```typescript:request.dto.ts
const findUserByIdRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});

type FindUserByIdRequest = z.infer<typeof findUserByIdRequestSchema>;
```

```typescript:response.dto.ts
const findUserByIdResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});

type FindUserByIdResponse = z.infer<typeof findUserByIdResponseSchema>;
```

---

## Access Guards

Access guards are **functions** (not classes) that determine if a request is allowed.

**Type Definition:**

```typescript
type AccessGuard<T = unknown> = (
  request: T,
) => AccessGuardResult | Promise<AccessGuardResult>;

interface AccessGuardResult {
  isAllowed: boolean;
  reason?: string;
}
```

**Example:**

```typescript:access-guard.ts
import type { AccessGuard, AccessGuardResult } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Simple guard
const requireAdmin: AccessGuard<MyRequest> = (request) => ({
  isAllowed: request.data.role === 'admin',
  reason: 'Admin access required',
});

// Guard using a use case (via closure)
const createCanManageResourceGuard = (
  canManageQuery: CanManageResourceQueryInboundPort,
): AccessGuard<MyRequest> => async (request) => {
  const result = await canManageQuery.execute({
    userId: request.data.userId,
    resourceId: request.data.resourceId,
  });
  return { isAllowed: result.allowed, reason: result.reason };
};
```

**Rules:**
- ✅ Functions, not classes
- ✅ Can use closures for dependency injection
- ✅ Delegate authorization logic to use cases
- ❌ Cannot implement custom business logic

---

## Mappers

Pure functions transforming between HTTP and use case shapes.

```typescript:to-use-case.mapper.ts
function toFindUserByIdInput(request: FindUserByIdRequest): FindUserByIdInput {
  return { userId: request.pathParams.userId };
}

// to-response.mapper.ts
function toFindUserByIdResponse(output: FindUserByIdOutput): FindUserByIdResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

---

## Execution Context

Generated at controller level. **Never a frontend concern.**

```typescript
// Inside controller/handler
const executionContext = {
  userId: extractUserIdFromToken(request),
  roles: extractRolesFromToken(request),
};
```

---

## Controllers

The library provides `BaseController` and `GuardedController` for building type-safe controller pipelines.

### BaseController

Simple pipeline: validate request → map to use case input → execute → map response.

```typescript
import { BaseController } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

const getUserController = BaseController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
});

// Execute
const response = await getUserController.execute(requestDto);
```

### GuardedController

Extends `BaseController` with an access guard.

```typescript
import { GuardedController } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

const updateUserController = GuardedController.create({
  requestMapper: (req) => UpdateUserInputDto.create(req.data),
  useCase: updateUserCommand,
  responseMapper: (output) => UpdateUserResponseDto.create(output.data),
  accessGuard: async (req) => ({
    isAllowed: req.data.role === 'admin',
    reason: 'Admin access required',
  }),
});
```

### Generic Type Parameters

Both controllers use 4 generic type parameters, all extending `BaseDto<unknown>`:

```typescript
class BaseController<
  TRequestDto extends BaseDto<unknown>,  // HTTP request DTO
  TResponseDto extends BaseDto<unknown>, // HTTP response DTO
  TInDto extends BaseDto<unknown>,       // Use case input DTO
  TOutDto extends BaseDto<unknown>,      // Use case output DTO
>
```

---

## Exception Handling

Controllers automatically convert `ObjectValidationError` to `InvalidRequestError`.

For framework-specific exception handling, use the error handlers from framework integrations:

```typescript
// Hono
import { onionErrorHandler } from '@cosmneo/onion-lasagna/backend/frameworks/hono';
app.onError(onionErrorHandler);

// Elysia
import { onionErrorHandler } from '@cosmneo/onion-lasagna/backend/frameworks/elysia';
app.error(onionErrorHandler);

// Fastify
import { onionErrorHandler } from '@cosmneo/onion-lasagna/backend/frameworks/fastify';
app.setErrorHandler(onionErrorHandler);
```
