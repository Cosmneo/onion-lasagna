---
title: "New Endpoint"
description: "Step-by-step guide to creating a new HTTP endpoint"
icon: "route"
---

## Decision: Direct BC vs Orchestration

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Steps

### 1. Create Request/Response DTOs

```typescript:presentation/http/users/get-user/request.dto.ts
const getUserRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});
type GetUserRequest = z.infer<typeof getUserRequestSchema>;

// presentation/http/users/get-user/response.dto.ts
const getUserResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});
type GetUserResponse = z.infer<typeof getUserResponseSchema>;
```

### 2. Create Endpoint Metadata

```typescript:presentation/http/users/get-user/endpoint.metadata.ts
export const getUserMetadata = {
  method: 'GET' as const,
  path: '/users/:userId',
};
```

### 3. Define Inbound Port (in BC)

```typescript:app/ports/inbound/get-user.query.inbound.ts
interface GetUserQueryInboundPort {
  execute(input: GetUserInput): Promise<GetUserOutput>;
}
```

### 4. Implement Use Case

```typescript:app/use-cases/queries/get-user.use-case.ts
import { BaseInboundAdapter, NotFoundError } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

class GetUserQuery
  extends BaseInboundAdapter<GetUserInputDto, GetUserOutputDto>
  implements GetUserQueryInboundPort
{
  constructor(private readonly userRepo: UserReadRepositoryOutboundPort) {
    super();
  }

  protected async handle(input: GetUserInputDto): Promise<GetUserOutputDto> {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    return GetUserOutputDto.create({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Extend `BaseInboundAdapter` and implement `handle()` for automatic error wrapping. The inherited `execute()` method handles error boundaries.

### 5. Create Mappers

```typescript:presentation/http/users/get-user/to-use-case.mapper.ts
function toGetUserInput(request: GetUserRequest): GetUserInput {
  return { userId: request.pathParams.userId };
}

// presentation/http/users/get-user/to-response.mapper.ts
function toGetUserResponse(output: GetUserOutput): GetUserResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

### 6. Create Access Guard (if needed)

Access guards are **functions**, not classes:

```typescript:presentation/http/users/get-user/access-guard.ts
import type { AccessGuard } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Simple guard - allow any authenticated user
const getUserAccessGuard: AccessGuard<GetUserRequestDto> = (request) => ({
  isAllowed: true,
});

// Guard with authorization check
const getUserAccessGuardWithAuth: AccessGuard<GetUserRequestDto> = async (request) => {
  const isOwner = request.data.pathParams.userId === request.data.currentUserId;
  return {
    isAllowed: isOwner,
    reason: isOwner ? undefined : 'You can only view your own profile',
  };
};
```

### 7. Wire in Bootstrap

```typescript:bootstrap/user.bootstrap.ts
const userReadRepo = new UserRepository(new UserPersistence());
const getUserQuery = new GetUserQuery(userReadRepo);
```

### 8. Create Controller

Use `BaseController` or `GuardedController` to wire the pipeline:

```typescript:presentation/http/users/get-user/controller.ts
import { BaseController, GuardedController } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Without access guard
const getUserController = BaseController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
});

// With access guard
const getUserControllerGuarded = GuardedController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
  accessGuard: getUserAccessGuard,
});
```

---

## Checklist

- [ ] Request/Response DTOs created
- [ ] Endpoint metadata created
- [ ] Inbound port defined
- [ ] Use case implemented
- [ ] Mappers created
- [ ] Access guard created (if needed)
- [ ] Bootstrap wired
- [ ] Controller created (or generated)
