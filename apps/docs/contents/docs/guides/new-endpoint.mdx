---
title: "New Endpoint"
description: "Step-by-step guide to creating a new HTTP endpoint"
icon: "route"
---

## Decision: Direct BC vs Orchestration

| Scenario | Approach |
|----------|----------|
| Single BC, self-contained | Direct BC call |
| Multiple BCs needed | Orchestration |

---

## Steps

### 1. Create Request/Response DTOs

```typescript:presentation/http/users/get-user/request.dto.ts
const getUserRequestSchema = z.object({
  pathParams: z.object({
    userId: z.string().uuid(),
  }),
});
type GetUserRequest = z.infer<typeof getUserRequestSchema>;

// presentation/http/users/get-user/response.dto.ts
const getUserResponseSchema = z.object({
  id: z.string().uuid(),
  email: z.string(),
  name: z.string(),
});
type GetUserResponse = z.infer<typeof getUserResponseSchema>;
```

### 2. Create Endpoint Metadata

```typescript:presentation/http/users/get-user/endpoint.metadata.ts
import type { HttpEndpointMetadata } from '@cosmneo/onion-lasagna/backend/core/presentation';

export const getUserMetadata: HttpEndpointMetadata = {
  id: 'get-user',
  shortId: 'gu',
  name: 'getUser',
  description: 'Gets a user by their ID.',
  method: 'GET',
  path: '/{userId}',  // Use {param} syntax - converted to :param by framework
  openApi: {
    summary: 'Get user by ID',
  },
};
```

<Callout type="info">
Paths use `{param}` syntax which is framework-agnostic. Framework integrations convert to the appropriate format (e.g., `:param` for Hono/Express).
</Callout>

**OpenAPI successStatus defaults:**

| Method | Default Status | When to Override |
|--------|----------------|------------------|
| GET | 200 | Rarely needed |
| POST | 201 | Use 200 for non-creation operations |
| PUT | 200 | Use 204 for no-content responses |
| PATCH | 200 | Use 204 for no-content responses |
| DELETE | 204 | Use 200 if returning deleted resource |

```typescript:endpoint.metadata.ts
// POST that creates - use default 201
openApi: { summary: 'Create user' }

// POST that doesn't create - override to 200
openApi: { summary: 'Login', successStatus: 200 }

// DELETE with no response body - use default 204
openApi: { summary: 'Delete user' }
```

### 3. Define Inbound Port (in BC)

```typescript:app/ports/inbound/get-user.query.inbound.ts
interface GetUserQueryInboundPort {
  execute(input: GetUserInput): Promise<GetUserOutput>;
}
```

### 4. Implement Use Case

```typescript:app/use-cases/queries/get-user.use-case.ts
import { BaseInboundAdapter, NotFoundError } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

class GetUserQuery
  extends BaseInboundAdapter<GetUserInputDto, GetUserOutputDto>
  implements GetUserQueryInboundPort
{
  constructor(private readonly userRepo: UserReadRepositoryOutboundPort) {
    super();
  }

  protected async handle(input: GetUserInputDto): Promise<GetUserOutputDto> {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    return GetUserOutputDto.create({
      id: user.id.value,
      email: user.email,
      name: user.name,
    });
  }
}
```

**Note:** Extend `BaseInboundAdapter` and implement `handle()` for automatic error wrapping. The inherited `execute()` method handles error boundaries.

### 5. Create Mappers

```typescript:presentation/http/users/get-user/to-use-case.mapper.ts
function toGetUserInput(request: GetUserRequest): GetUserInput {
  return { userId: request.pathParams.userId };
}

// presentation/http/users/get-user/to-response.mapper.ts
function toGetUserResponse(output: GetUserOutput): GetUserResponse {
  return { id: output.id, email: output.email, name: output.name };
}
```

### 6. Create Access Guard (if needed)

Access guards are **functions**, not classes:

```typescript:presentation/http/users/get-user/access-guard.ts
import type { AccessGuard } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Simple guard - allow any authenticated user
const getUserAccessGuard: AccessGuard<GetUserRequestDto> = (request) => ({
  isAllowed: true,
});

// Guard with authorization check
const getUserAccessGuardWithAuth: AccessGuard<GetUserRequestDto> = async (request) => {
  const isOwner = request.data.pathParams.userId === request.data.currentUserId;
  return {
    isAllowed: isOwner,
    reason: isOwner ? undefined : 'You can only view your own profile',
  };
};
```

### 7. Wire in Bootstrap

```typescript:bootstrap/user.bootstrap.ts
const userReadRepo = new UserRepository(new UserPersistence());
const getUserQuery = new GetUserQuery(userReadRepo);
```

### 8. Create Controller

Use `BaseController` or `GuardedController` to wire the pipeline:

```typescript:presentation/http/users/get-user/controller.ts
import { BaseController, GuardedController } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

// Without access guard
const getUserController = BaseController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
});

// With access guard
const getUserControllerGuarded = GuardedController.create({
  requestMapper: (req: GetUserRequestDto) =>
    GetUserInputDto.create({ userId: req.data.pathParams.userId }),
  useCase: getUserQuery,
  responseMapper: (output: GetUserOutputDto) =>
    GetUserResponseDto.create(output.data),
  accessGuard: getUserAccessGuard,
});
```

---

## Void Operations (DELETE, UPDATE)

For operations that return no content (HTTP 204):

### Port with void output

```typescript:app/ports/inbound/delete-user.command.port.ts
import type { BaseInboundPort } from '@cosmneo/onion-lasagna/backend/core/onion-layers';

interface DeleteUserPort extends BaseInboundPort<DeleteUserInputDto, void> {}
```

### Use Case returning void

Since `BaseInboundAdapter` requires a DTO output, create a void adapter in your codebase:

<Callout type="info">
`BaseVoidInboundAdapter` is **not** a library exportâ€”it's a pattern you implement. Create this class once in your project and reuse it for all void-returning use cases.
</Callout>

```typescript:app/use-cases/base-void-inbound-adapter.ts
import { BaseInboundPort, UseCaseError, DomainError, InfraError } from '@cosmneo/onion-lasagna/backend/core/onion-layers';
import { ObjectValidationError, wrapErrorUnlessAsync } from '@cosmneo/onion-lasagna/backend/core/global';

export abstract class BaseVoidInboundAdapter<TInDto extends BaseDto<unknown>>
  implements BaseInboundPort<TInDto, void>
{
  protected abstract handle(input: TInDto): Promise<void>;

  public async execute(input: TInDto): Promise<void> {
    return wrapErrorUnlessAsync(
      () => this.handle(input),
      (cause) => new UseCaseError({ message: 'Unexpected use case error', cause }),
      [ObjectValidationError, UseCaseError, DomainError, InfraError],
    );
  }
}
```

```typescript:app/use-cases/commands/delete-user.command.ts
class DeleteUserUseCase extends BaseVoidInboundAdapter<DeleteUserInputDto> implements DeleteUserPort {
  constructor(private readonly userRepo: UserRepositoryPort) {
    super();
  }

  protected async handle(input: DeleteUserInputDto): Promise<void> {
    const user = await this.userRepo.findById(UserId.create(input.data.userId));
    if (!user) {
      throw new NotFoundError({ message: `User ${input.data.userId} not found` });
    }
    await this.userRepo.delete(user.id);
  }
}
```

### Response mapper for 204

```typescript:presentation/http/users/delete-user/mappers.ts
import type { DtoValidator } from '@cosmneo/onion-lasagna/backend/core/global';

export function deleteUserToResponseMapper(
  validator: DtoValidator<DeleteUserResponseData>,
): DeleteUserResponseDto {
  return new DeleteUserResponseDto(
    { statusCode: 204, body: null },
    validator,
  );
}
```

### Controller for void operations

```typescript:bootstrap/controller.bootstrap.ts
deleteUserController: BaseController.create({
  requestMapper: (req: DeleteUserRequestDto) =>
    deleteUserToInputMapper(req, SKIP_DTO_VALIDATION),
  useCase: deleteUserUseCase,
  // Response mapper ignores output (void) and returns 204
  responseMapper: () => deleteUserToResponseMapper(SKIP_DTO_VALIDATION),
}),
```

<Callout type="info">
For void operations, the `responseMapper` receives `void` and returns a 204 response with `body: null`.
</Callout>

---

## Checklist

- [ ] Request/Response DTOs created
- [ ] Endpoint metadata created
- [ ] Inbound port defined
- [ ] Use case implemented
- [ ] Mappers created
- [ ] Access guard created (if needed)
- [ ] Bootstrap wired
- [ ] Controller created (or generated)
